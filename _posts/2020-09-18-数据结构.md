---
layout:     post
title:      "数据结构"
subtitle:   "数据结构及代码实现"
date:       2020-09-18
author:     "aptx1231"
header-img: "img/bg/2020-09-18-数据结构.jpg"
tags:       [禁止转载,数据结构,课程整理]
categories: [课程整理]
catalog:    []
---

>截图来自浙江大学授课老师PPT[慕课]，请勿转载

# 线性结构 #

## 线性表 ##

### 顺序存储 ###

```c++
typedef int Position;
typedef struct LNode * List;
typedef int ElementType;
struct LNode {
    ElementType Data[MAXSIZE];
    Position Last;  //最后元素的下标 
};
```

按值查找O(n)

按序号查找O(1)

插入O(n)

删除O(n)

### 链式存储 ###

```c++
typedef int ElementType;
struct LNode {
    ElementType Data;
    struct LNode * Next;
};
typedef struct LNode * Position;
typedef struct LNode * List;

List p;
p->Data=X;
```

按值查找O(n)

按序号查找O(n)

插入O(1)

删除O(1)

## 堆栈 ##

“堆栈（Stack）”可以认为是具有一定操作约束的线性表，插入和删除操作都作用在一个称为栈顶(Top)的端点位置

### 顺序存储 ###

```c++
typedef int Position;
typedef int ElementType;
struct SNode{
	ElementType *Data;  //指针就是数组 
	Position Top;       //栈顶指针位置 
	int maxsize;
}; 
typedef struct SNode* PtrToSNode;
typedef PtrToSNode Stack;

//S->Top==S->maxsize-1 堆栈满
//S->Top==-1 堆栈空
//入栈 (S->Top)++; S->Data[S->Top]=X;
//出栈 return S->Data[(S->Top)--];
```

### 链式存储 ###

```c++
typedef int ElementType;
struct SNode{
	ElementType Data;//链表 
    struct SNode* next;
}; 
typedef struct SNode* PtrToSNode;
typedef PtrToSNode Stack;

//S->next==NULL 堆栈空
//入栈 p->next=S->next; S->next=p;  S是空头
//出栈 p=S->next; S->next=p->next;
```

**中缀表达式转换为后缀表达式**

从头到尾读取中缀表达式的每个对象，对不同对象按不同的情况处理。对象分下列6种情况:

①如果遇到空格则认为是分隔符，不需处理；

②若遇到运算数，则直接输出；

③若是左括号，则将其压入堆栈中；

④若遇到的是右括号，表明括号内的中缀表达式已经扫描完毕，将栈顶的运算符弹出并输出，直到遇到左括号（左括号也出栈，但不输出）；

⑤若遇到的是运算符，若该运算符的优先级大于栈顶运算符的优先级时，则把它压栈；若该运算符的优先级小于等于栈顶运算符时，将栈顶运算符弹出并输出，再比较新的栈顶运算符，按同样处理方法，直到该运算符大于栈顶运算符优先级为止，然后将该运算符压栈；

⑥若中缀表达式中的各对象处理完毕，则把堆栈中存留的运算符一并输出。

## 队列 ##

“队列(Queue)” 是具有一定操作约束的线性表，插入和删除操作有一定要求：只能在一端插入，而在另一端删除

### 顺序存储 ###

```c++
typedef int Position;
typedef int ElementType; 
struct QNode {
	ElementType *Data;//数组 
	int maxsize;
	Position front;//front+1是开头位置--这个代码
	Position rear;//下标，头尾指针
}; 
typedef struct QNode* PtrToQNode;
typedef PtrToQNode Queue;

//(Q->rear+1)%(Q->maxsize)==(Q->front) 队列满
//Q->front==Q->rear 队列空
//出队 Q->front=(Q->front+1)%(Q->maxsize);
//入队 Q->rear=(Q->rear+1)%(Q->maxsize);  Q->Data[Q->rear]=X;
```


### 链式存储 ###

```C++
typedef int ElementType;
typedef struct Node* PtrToNode;
struct Node { 
    ElementType Data;
    struct Node* next;
};
typedef PtrToNode Position;

struct QNode {
    struct Node* front;
	struct Node* rear;  /* 队列的头、尾指针 */         
};
//只是把两个指针f,r当成一个结构，通过f,r可以访问每个节点，实际上QNode可有可无
//Queue Q; Q->front->next Q->front->Data
typedef struct QNode* Queue;

//Q->front==NULL 队列空
//Q->front==Q->rear 队列只有一个元素
//出队 Q->front=Q->front->next
//入队 Q->rear->next=q; Q->rear=q;
```

# 树 #

## 基本概念 ##

树（Tree）是n（n≥0）个结点构成的有限集合。当n=0时，称为空树。

树中有一个称为“根（Root）”的特殊结点，用 r 表示；

其余结点可分为m(m>0)个互不相交的有限集T1，T2，... ，Tm，其中每个集合本身又是一棵树，这些树称为原来树的“子树（SubTree）”。每个子树的根结点都与 r 有一条相连接的边，r是这些子树根结点的“父结点(Parent)”。

子树是不相交的。

除了根结点外，每个结点有且仅有一个父结点。

一棵N个结点的树有N-1条边。

基本概念：

**结点的度（Degree）：一个结点的度是其子树的个数。**

树的度：树的所有结点中最大的度数。

叶结点（Leaf）：是度为0的结点；叶结点也可称为端结点。

父结点（Parent）：有子树的结点是其子树的根结点的父结点。

子结点（Child）：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点。

兄弟结点（Sibling）：具有同一父结点的各结点彼此是兄弟结点。

分支：树中两个相邻结点的连边称为一个分支。

路径和路径长度：从结点n1到nk的路径被定义为一个结点序列n1 , n2 ,… , nk ，对于1 i  k, ni是 ni+1的父结点。一条路径的长度为这条路径所包含的边（分支）的个数。

祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。

子孙结点(Descendant)：某一结点的子树中的所有结点是这个结点的子孙。

结点的层次（Level）：规定根结点在1层，其它任一结点的层数是其父结点的层数加1。

树的高度（Height）：树中所有结点中的最大层次是这棵树的高度（也有把根定义成高度为1的） 。

## 二叉树 ##

一棵二叉树T是一个有穷的结点集合。这个集合可以为空，若不为空，则它是由根结点和称为其左子树TL和右子树TR的两个不相交的二叉树组成。

![1597738744647](../../../../../../img/in-post/2020-09-18-数据结构/1597738744647.png)

![1597738785580](../../../../../../img/in-post/2020-09-18-数据结构/1597738785580.png)

![1597739004457](../../../../../../img/in-post/2020-09-18-数据结构/1597739004457.png)

### 顺序存储 ###

![1597739046753](../../../../../../img/in-post/2020-09-18-数据结构/1597739046753.png)

### 链式存储 ###

```c++
typedef int ElementType;
typedef struct TNode *BinTree;/* 二叉树类型 */
struct TNode{ /* 树结点定义 */
    ElementType Data; /* 结点数据 */
    BinTree Left;     /* 指向左子树 */
    BinTree Right;    /* 指向右子树 */
};
```

### 递归遍历 ###

先序遍历 根左右

```c++
//先序遍历 根左右 
void PreOrderTraversal(BinTree BT)
{
	if(BT){
		printf("%d ",BT->Data);
		PreOrderTraversal(BT->Left);
		PreOrderTraversal(BT->Right);
	}
}
```

中序遍历 左根右 

```c++
void InOrderTraversal(BinTree BT)
{
	if(BT){
		InOrderTraversal(BT->Left);
		printf("%d ",BT->Data);
		InOrderTraversal(BT->Right);
	}
}
```

后序遍历 左右根

```c++
void PostOrderTraversal(BinTree BT)
{
	if(BT){	
		PostOrderTraversal(BT->Left);
		PostOrderTraversal(BT->Right);
		printf("%d ",BT->Data);
	}
}
```

**中序+后序或者中序+先序都可以唯一确定一棵树。**

### 非递归遍历 ###

先序遍历 根左右

```c++
void PreOrderTraversal(BinTree BT)
{
	BinTree T=BT;
	Stack S=CreateStack();/* 创建并初始化堆栈S*/
	while(T||!IsEmptyS(S)){
		while(T){/*一直向左并将沿途结点压入堆栈*/
			printf("%5d",T->Data);
			Push(S,T);
			T=T->Left;
		}
		//左侧没有了就弹出 
		T=Pop(S);
		T=T->Right;//对于每个弹出的节点去找右侧 
	}
}
```
中序遍历 左根右 

```c++
void InOrderTraversal(BinTree BT)
{
	BinTree T=BT;
	Stack S=CreateStack();/* 创建并初始化堆栈S*/
	while(T||!IsEmptyS(S)){
		while(T){/*一直向左并将沿途结点压入堆栈*/
			Push(S,T);
			T=T->Left;
		}
		//左侧没有了就弹出 
		T=Pop(S);
		printf("%5d",T->Data);
		T=T->Right;//对于每个弹出的节点去找右侧 
	}
}
```

后序遍历 左右根

```c++
void PostOrderTraversal(BinTree BT) 
{
	BinTree T=BT;
	//...
    //先要让树里的每个元素flag为1
	//...
    Stack S=CreateStack();/* 创建并初始化堆栈S*/
	while(T||!IsEmptyS(S)){
		while(T){/*一直向左并将沿途结点压入堆栈*/
			Push(S,T);
			T=T->Left;
		}
		T=Pop(S);
		if(T->flag==0){//f=0代表入栈两次 直接访问此节点 
			printf("%5d",T->Data);
			T->Right=NULL; //打印之后，右侧填成NULL，否则还会向右找 
		}else{ //f=1代表第一次访问到 压栈 改flag
			Push(S,T);
			T->flag=0;		
		}
		T=T->Right;//对于每个弹出的节点去找右侧 
	}
}
```

### 层序遍历 ###

```c++
void LevelOrderTraversal(BinTree BT)
{
	Queue Q;
	BinTree T;
	if(!BT) return;//空树 
	Q=CreateQueue();
	AddQ(Q,BT);
	while(!IsEmpty(Q)){
		T=DeleteQ(Q);
		printf("%d ",T->Data);
		if(T->Left) AddQ(Q,T->Left);
		if(T->Right) AddQ(Q,T->Right);
	}
}
```

### 求树高 ###

```c++
int GetHeight(BinTree BT)
{
	int HL,HR,MAX;
	if(BT){
		HL=GetHeight(BT->Left);
		HR=GetHeight(BT->Right);	
		MAX=HL>HR ? HL:HR;
		return (MAX+1);
	}
	else{
		return 0; //空树高度为0 
	}
} 
```

## 二叉搜索树 ##

一个二叉搜索树是一棵二叉树，它可以为空。如果不为空，它将满足以下性质：

**非空左子树的所有键值小于其根结点的键值。**

**非空右子树的所有键值大于其根结点的键值。**

**左、右子树都是二叉搜索树。**

### 查找 ###

```c
_Position Find(BinTree BST,ElementType X)
{//尾递归 
	if(!BST) return NULL;//BST空
	if(X>BST->Data){
		return Find(BST->Right,X);
	}else if(X<BST->Data){
		return Find(BST->Left,X); 
	}else{
		return BST;
	}	
} 

_Position IterFind(BinTree BST,ElementType X)
{//迭代代替尾递归 
	while(BST){
		if(X>BST->Data){
			BST=BST->Right;
	    }else if(X<BST->Data){
			BST=BST->Left; 
		}else{
			return BST;//查找成功 
		}
	}
	return NULL;//查找失败 
}
```

### 查找最小值 ###

最小元素一定是在树的最左分枝的端结点上

```c
_Position FindMin(BinTree BST)
{
	if(!BST){
		return NULL;//BST空
	} 
	else if(!BST->Left){ //左侧空了，就找到了最小值 
		return BST;
	}else{//左侧不空，一直向左找 
		return FindMin(BST->Left);
	}
}

_Position IterFindMin(BinTree BST)
{
	if(BST){
		while(BST->Left){//左侧不空一直向左 
			BST=BST->Left;
		}
	}
	return BST;//BST空，也对，也就是return NULL 
}
```

### 查找最大值 ###

最大元素一定是在树的最右分枝的端结点上

```c
_Position FindMax(BinTree BST)
{
	if(!BST){
		return NULL;//BST空
	} 
	else if(!BST->Right){//右侧空了，就找到了最大值 
		return BST;
	}else{//右侧不空，一直向右找 
		return FindMax(BST->Right);
	}
}

_Position IterFindMax(BinTree BST)
{
	if(BST){
		while(BST->Right){//右侧不空一直向右 
			BST=BST->Right;
		}
	}
	return BST;//BST空，也对，也就是return NULL 
}
```

### 插入 ###

```c
BinTree Insert(BinTree BST, ElementType X)
{
	if(!BST){/* 若原树为空，生成并返回只有一个结点的二叉搜索树 */
		BST=(BinTree)malloc(sizeof(struct TNode));
		BST->Data=X;
		BST->Left=BST->Right=NULL;
	}else{
		if(X<BST->Data){
			BST->Left = Insert(BST->Left,X); /*递归插入左子树*/
		}else if(X>BST->Data){
			BST->Right = Insert(BST->Right,X);/*递归插入右子树*/
		}
		//else X=BST->Data 原本就存在，什么都不做	
	}
	return BST;	
} 

BinTree IterInsert(BinTree BST,ElementType X)
{
	BinTree P,q=BST;//树根不要变  不引入q也可以 只不过就只有NULL传进来才接收那个返回值就行了 
	P=(BinTree)malloc(sizeof(struct TNode));
	P->Data=X;
	P->Left=P->Right=NULL;
	if(q==NULL){
		BST=P;
	}
	else{
		while(1){
			if(q->Data>X){//插在左子树 
				if(q->Left==NULL){
					q->Left=P;//插入成功 
					break;
				} 
				else{
					q=q->Left;//不能插在此处 以他的左儿子为根再去找 
				}
			}
			else if(q->Data<X){
				if(q->Right==NULL){
					q->Right=P;
					break;
				}
				else{
					q=q->Right;
				}
			}
			//else ... break...相等不用插入 
		}	
	}
	return BST;
}
```

### 删除 ###

（1）![1597741502196](../../../../../../img/in-post/2020-09-18-数据结构/1597741502196.png)

（2）![1597741515986](../../../../../../img/in-post/2020-09-18-数据结构/1597741515986.png)

（3）![1597741536953](../../../../../../img/in-post/2020-09-18-数据结构/1597741536953.png)

```c
BinTree Delete(BinTree BST,ElementType X)
{
	_Position Tmp;
	if(!BST){
		printf("要删除的元素未找到");
	}else{
		if(X<BST->Data) { //删除之后的子树必须赋值给BST->Left
            BST->Left = Delete(BST->Left,X);   /* 从左子树递归删除 */
        } else if(X>BST->Data) {
            BST->Right = Delete(BST->Right,X); /* 从右子树递归删除 */
        } else {//找到了，要把BST删掉 
			if (BST->Left&&BST->Right){/* 如果被删除结点有左右两个子结点，左右都不空 */
				//方法一：找右侧最小值 
				//Tmp=FindMin(BST->Right); //从右子树中找最小的元素
                //BST->Data=Tmp->Data;     //填充到BST 
                //BST->Right=Delete(BST->Right,Tmp->Data);// 从右子树中删除最小元素Tmp
                //方法二：找左侧最大值也可以 
                Tmp=FindMax(BST->Left);
                BST->Data=Tmp->Data;
                BST->Left=Delete(BST->Left,Tmp->Data);
			} else {/* 被删除结点有一个或无子结点 */
				Tmp=BST;
				if(!BST->Left){/* 只有右孩子或无子结点 */
					BST=BST->Right;//BST变成右孩子，返回给递归的上一层，之后就会挂到上一层的根节点上
				}
				else{ /* 只有左孩子 */
					BST=BST->Left;
				}
				free(Tmp);
			} 
		}
	}
	return BST;
} 
```

## 平衡二叉树 AVL ##

对于二叉树中任一结点T，其“平衡因子（Balance Factor，简称BF）”定义为BF(T) = hL-hR，其中hL和hR分别为T的左、右子树的高度。

“平衡二叉树（Balanced Binary Tree）”又称为“AVL树” 。 AVL树或者是一棵空树，或者是具有下列性质的**非空二叉搜索树**：“**任一结点左、右子树高度差的绝对值不超过1**”。即|BF(T) |≤ 1。

给定结点数为 n的AVL树的最大高度为O(log2n)

保证了**AVL树的查找时间性能为O(log2n)**

```c
typedef struct AVLNode* Position;
typedef Position AVLTree;
typedef int ElementType; 
struct AVLNode{
	ElementType Data;
	AVLTree Left; /* 指向左子树 */
	AVLTree Right;/* 指向右子树 */
	int Height;/* 树高，判断平衡的标志*/
};
```

构建AVL时，插入节点可能导致树不平衡，需要通过以下四种旋转进行调整：

### RR旋转 ###

![1597825483102](../../../../../../img/in-post/2020-09-18-数据结构/1597825483102.png)

```c
AVLTree SingleRightRotion(AVLTree A)//RR
{
	AVLTree B;
	B=A->Right;
	A->Right=B->Left;
	B->Left=A;
	A->Height=max(GetHeight(A->Left),GetHeight(A->Right))+1;
	B->Height=max(GetHeight(B->Right),A->Height)+1;
	return B;
} 
```

### LL旋转 ###

![1597825515118](../../../../../../img/in-post/2020-09-18-数据结构/1597825515118.png)

```c
AVLTree SingleLeftRotion(AVLTree A)//LL
{/* 注意：A必须有一个左子结点B */
/* 将A与B做左单旋，更新A与B的高度，返回新的根结点B */     
	AVLTree B;//看图容易写出 
	B=A->Left;//B记录下AL 
	A->Left=B->Right;//AL记录BR 
	B->Right=A;//A放在B右侧 
	A->Height=max(GetHeight(A->Left),GetHeight(A->Right))+1;
	B->Height=max(GetHeight(B->Left),A->Height)+1;
	return B;//新的根 
} 
```

### LR旋转 ###

（相当于对B做RR后，作为A的左子树，然后对A作LL）

![1597825555227](../../../../../../img/in-post/2020-09-18-数据结构/1597825555227.png)

```c
AVLTree DoubleLeftRightRotion(AVLTree A)//LR
{ /* 注意：A必须有一个左子结点B，且B必须有一个右子结点C */
  /* 将A、B与C做两次单旋，返回新的根结点C */
    /* 将B与C做右单旋，C被返回 */
	A->Left=SingleRightRotion(A->Left);//A->Left是B，函数return B，传给了A->Left，就是那个C
	/* 将A与C做左单旋，C被返回 */
	return SingleLeftRotion(A);//A->Left是C，函数return B，就是C 
}
```

### RL旋转 ###

（相当于对B做LL后，作为A的右子树，然后对A作RR）

![1597825610859](../../../../../../img/in-post/2020-09-18-数据结构/1597825610859.png)

```c
AVLTree DoubleRightLeftRotion(AVLTree A)//RL
{ /* 注意：A必须有一个右子结点B，且B必须有一个左子结点C */
  /* 将A、B与C做两次单旋，返回新的根结点C */
	/* 将B与C做左单旋，C被返回 */
	A->Right=SingleLeftRotion(A->Right);//A->Right是B，函数return B，传给了A->Right，就是那个C
	/* 将A与C做右单旋，C被返回 */ 
	return  SingleRightRotion(A);//A->Right是C，函数return B，就是C 
} 
```

### 插入 ###

```c
//与普通二叉搜索树插入算法比较，就是多了判断是不是需要旋转调整的过程
AVLTree Insert(AVLTree T,ElementType X)
{/* 将X插入AVL树T中，并且返回调整后的AVL树 */
	if(!T){/* 若插入空树，则新建包含一个结点的树 */
		T=(AVLTree)malloc(sizeof(struct AVLNode));
		T->Data=X;
		T->Height=0;
		T->Left=T->Right=NULL;
	}
	else if(X<T->Data){ 
		T->Left=Insert(T->Left,X);/* 插入T的左子树 */
		if(GetHeight(T->Left)-GetHeight(T->Right)==2){/* 不平衡需要左旋 */
			//用X和它的父节点(T->Left)比较看插在父节点左还是右 
			if(X<T->Left->Data){/*判断LL还是LR，利用看插入在左子树的左侧还是右侧*/ 
				T=SingleLeftRotion(T);//LL 
			}else{
				T=DoubleLeftRightRotion(T);//LR
			}
		}
	}
	else if(X>T->Data){
		T->Right=Insert(T->Right,X);/* 插入T的右子树 */
		if(GetHeight(T->Left)-GetHeight(T->Right)==-2){/* 不平衡需要右旋 */
			//用X和它的父节点(T->Right)比较看插在父节点左还是右
			if(X>T->Right->Data){
				T=SingleRightRotion(T);//RR
			}else{
				T=DoubleRightLeftRotion(T);//RL
			}
		}	 
	}//else 即X=T->Data,无需插入，什么都不做
	//走到这一步，说明已经把要插入的数据插入了，T就是新的树了，更新高度 
	//不是在之前的高度T->Height加一，因为旋转了，而是重新计算左右子树高度的较大值加一 
	T->Height=max(GetHeight(T->Left),GetHeight(T->Right))+1;//更新树高  
	return T; 
}
```

## 堆 ##

“优先队列” （Priority Queue）是特殊的“队列”，从堆中取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。**采用完全二叉树存储的优先队列称为堆（Heap）**。

最大堆

一个有N>0个元素的**最大堆H是一棵完全二叉树**，**每个结点上的元素值不小于其子结点元素的值。**

只是保证父节点比子节点大，不能保证像二叉搜索树那样右边比左边大。

![1597840638983](../../../../../../img/in-post/2020-09-18-数据结构/1597840638983.png)

![1597840697326](../../../../../../img/in-post/2020-09-18-数据结构/1597840697326.png)

```c
typedef int ElementType;
typedef struct HNode* Heap;/* 堆的类型定义 */
struct HNode{
	ElementType *Data;/* 存储元素的数组 */
	int size; /* 堆中当前元素个数 */
	int Capacity; /* 堆的最大容量 */
}; 
typedef Heap MaxHeap; /* 最大堆 */
typedef Heap MinHeap; /* 最小堆 */
```

### 初始化堆 ###

```c
MaxHeap CreateHeap(int Maxsize)
{ /* 创建容量为MaxSize的空的最大堆 */
	MaxHeap H=(MaxHeap)malloc(sizeof(struct HNode));
	H->Data=(ElementType*)malloc((Maxsize+1)*sizeof(ElementType));
	H->size=0;
	H->Capacity=Maxsize;
	H->Data[0]=MAXDATA;/* 0号位置定义"哨兵"为大于堆中所有可能元素的值*/	
	return H;
} 
```

### 插入 ###

从新增的最后一个结点的父结点开始，用要插入元素向下过滤上层结点（相当于要插入的元素向上渗透）

```c
int Insert(MaxHeap H,ElementType X)
{ /* 将元素X插入最大堆H，其中H->Data[0]已经定义为哨兵 */
	if(IsFull(H)){
		printf("最大堆已满\n");
		return 0;
	}
	int i;
	i=++H->size;/* 先加！！i指向插入后堆中的最后一个元素的位置 */
	for(;X>H->Data[i/2];i/=2){//i/2是i的父节点 
		H->Data[i]=H->Data[i/2]; /* 上滤X */
	}//i不断除以2，会变成0，Data[0]是最大值，所以会出循环  
	H->Data[i]=X;/* 将X插入 */
	return 1;
}
```

### 删除 ###

删除最大值（序号1），用最大堆中最后一个元素从根结点开始向上过滤下层结点

```c
ElementType DeleteMax(MaxHeap H)
{/* 从最大堆H中取出键值为最大的元素，并删除一个结点 */
	if(IsEmpty(H)){
		printf("最大堆已为空\n");
        return -1;
	}
	
	ElementType MaxItem=H->Data[1];/* 取出根结点存放的最大值 */
	/* 用最大堆中最后一个元素从根结点开始向上过滤下层结点 */
	ElementType X;
	X=H->Data[H->size--];/*后减减,注意当前堆的规模要减小 */
	//假设把X放在了根节点的位置上，之后去移动，调成最大堆 
	int Parent,Child;
	for(Parent=1;Parent*2<=H->size;Parent=Child){//Parent*2<=H->size,一定存在左儿子 
		Child=2*Parent;//左儿子 
		if((Child!=H->size)&&(H->Data[Child+1]>H->Data[Child])){
			Child++;/* Child指向左右子结点的较大者 */
		}
		if(X>=H->Data[Child]){
			break;/* 找到了合适位置 */
		}else{ /* 下滤X */
			H->Data[Parent]=H->Data[Child];
		}
	} 
	H->Data[Parent]=X;//放置X
	return MaxItem;
}
```

### 创建堆 O(n) ###

如何将已经存在的N个元素按最大堆的要求存放在一个一维数组中

（1）一个一个插入，O(nlogn)

（2）O(n)的方法

第一步，将N个元素按输入顺序存入二叉树中，这一步只要求满足完全二叉树的结构特性，而不管其有序性。

第二步，调整各结点元素，以满足最大堆的有序特性。 **从最后一个结点的父节点开始，到根结点1结束，进行向下过滤，将大的值过滤上去，类似于删除堆的操作过程。**

```c
void BuildHeap(MaxHeap H)
{/* 调整H->Data[]中的元素，使满足最大堆的有序性  */
    int i;
    /* 从最后一个结点的父节点开始，到根结点1 */
    for(i=H->size/2;i>0;i--){
  		PercDown(H,i);
    }	
}

void PercDown(MaxHeap H, int p)
{/* 下滤：将H中以H->Data[p]为根的子堆调整为最大堆 */
	ElementType X;
	X=H->Data[p]; /* 取出根结点存放的值 */
	int Parent,Child;
	for(Parent=p;Parent*2<=H->size;Parent=Child){
		Child=Parent*2;
		if((Child!=H->size)&&(H->Data[Child+1]>H->Data[Child])){
			Child++;
		}
		if(X>=H->Data[Child]){
			break;
		}else{
			H->Data[Parent]=H->Data[Child];
		}
	}
	H->Data[Parent]=X;	
} 
```

## 哈夫曼树 ##

设一棵二叉树有n个叶子结点，每个叶子结点带有权值 wk，从根结点到每个叶子结点的长度为 lk，则每个叶子结点的带权路径长度之和就是这棵树的“带权路径长度（Weighted Path Length，简称WPL）”。

即![1597842119081](../../../../../../img/in-post/2020-09-18-数据结构/1597842119081.png)                       

假设有n个权值{w1 ,w2 , …… , wn} ，构造有n个叶子的二叉树，每个叶子的权值是n个权值之一。这样的二叉树也许可以构造多个，其中必有一个（或几个）是带权路径长度WPL最小的。

**达到WPL最小的二叉树就称为最优二叉树或哈夫曼树。**

```c
typedef struct HTNode* HuffmanTree;/*哈夫曼树类型*/
struct HTNode{/*哈夫曼树节点定义*/ 
	int Weight;/*节点权值*/
	HuffmanTree Left;/*指向左子树*/
	HuffmanTree Right;/*指向右子树*/
};
```

### 构造哈夫曼树 ###

按照权值的顺序，从小到大合并，**每次把权值最小的两颗二叉树合并**，合并的结果也要放回继续参与合并。每次要找最小的值，借用最小堆。一共需要合并N-1次。

```c
HuffmanTree Huffman(MinHeap H)
{/*  假设H->Size 个权值已经存在H->Elements[]->Weight 里 */
	HuffmanTree T;
	BuildHeap(H);   //把输入的权值构建成最小堆 
	int N=H->size;  //size会变 
	int i; 
	for(i=1;i<N;i++){
		T=(HuffmanTree)malloc(sizeof(struct HTNode));
		T->Left=DeleteMin(H);  //取最小的两个，作为左右儿子
		T->Right=DeleteMin(H);
		T->Weight=T->Left->Weight+T->Right->Weight;  //计算此树的权值
		Insert(H,T);   //放回最小堆中
	}
	T=DeleteMin(H);  //最后，最小堆只剩一棵树，就是最终的哈夫曼树
	return T;
} 
```

根据这个构造算法：

**哈夫曼树没有度为1的点**

**n个叶子结点的哈夫曼树共有2n-1个结点**

【出度只有0或2，n0个出度0的，n2个出度2的；入度除了根节点都为1，所以是n0+n2-1；入度=出度，n0+n2-1=2*n2，所以n2=n0-1。叶子节点出度为0有n个，也就是n0=n，所以n2=n-1，所以总个数=n0+n2=2n-1】

**哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树**

**在不考虑结点权值的情况下，如果二叉树A通过任意结点的左右子树交换，可以变成二叉树B，那么就称A和B是同构的。**

**与一棵哈夫曼树同构的二叉树都是哈夫曼树。**

**对同一组权值{w1 ,w2 , … , wn}，存在不同构的两棵哈夫曼树。**

### 计算WPL ###

```c
int WPL(HuffmanTree T,int Depth)//深度就是编码的长度 
{
	if(!T->Left&&!T->Right){//叶节点 只有叶节点才有权重和编码长度(深度) 
		return (Depth*T->Weight);
	} else { /*否则T一定有2个孩子,没有度为1的节点 */
		return (WPL(T->Left,Depth+1)+WPL(T->Right,Depth+1));
		//递归的计算左右子树的权值，注意深度加一 ！！ 
	}
}
```

### 哈夫曼编码 ###

**前缀编码是指对字符集进行编码时，要求字符集中任一字符的编码都不是其它字符的编码的前缀**

哈夫曼编码：由哈夫曼树得到的二进制前缀编码称为哈夫曼编码。

任意一个叶子结点都不可能在其它叶子结点的路径中。去任何一个叶节点时，都不能路过别的叶节点。

![1597843777786](../../../../../../img/in-post/2020-09-18-数据结构/1597843777786.png)

## 并查集 ##

### 初始化 ###

```c
//初始化并查集 
void InitializeVSet( SetType S, int N )
{ /* 初始化并查集 */
    ElementType X;
    for(X=0;X<N;X++){
    	S[X]=-1;
	} 
}
```

### 合并 ###

```c
//按秩归并——保证小集合并入大集合
//比规模---根节点的父节点不是存-1了 存的是节点个数的负值 
//最坏的树高O(logN) 
void Union(SetType S,SetName Root1,SetName Root2)
{ /* 这里默认Root1和Root2是不同集合的根结点 */
    /* 保证小集合并入大集合 */
    if(S[Root2]<S[Root1]) { /* 如果集合2比较大 */
        S[Root2]+=S[Root1];     /* 集合1并入集合2  */
        S[Root1]=Root2;
    }
    else{                         /* 如果集合1比较大 */
        S[Root1]+=S[Root2];     /* 集合2并入集合1  */
        S[Root2]=Root1;
    }
}
```

### 查找根节点 ###

```c
//路径压缩 
SetName Find(SetType S,ElementType X)
//元素X是下标，S[X]就是父节点，父节点为-1说明是根节点 
{ /* 默认集合元素全部初始化为-1 */
    if(S[X]<0) /* 找到集合的根 小于0说明这就是根节点*/
        return X;
    else
        return S[X]=Find(S,S[X]); /* 路径压缩 */  //必须return把根节点返回回去 
}       //递归的查找父节点S[X]的根节点 Find返回root是真正的根
		//S[X]=root X的父节点从原来是S[X]变成了root，直接挂到根上，压缩了树的高度 
		//实际上整个递归会把X到root的所有路过的节点全部变成root的孩子

//另一种写法 这里使用a[x]==x判断是不是根节点
int find(int k)
{
    int kk=k;
    while (a[kk] != kk) {
        kk = a[kk];
    } //kk是根节点
    int i;
    while (a[k]!=k) {
        i=k;
        k=a[k];
        a[i]=kk;  //从k到根节点路过的所有中间节点的父节点都设置为kk
    }
    return kk;
}
```

# 图 #

## 基本概念 ##

“图” G可以表示为两个集合：G =（V,  E）。每条边是一个顶点对（v, w） ∈ E ，并且 v, w ∈ V。

通常：用 |V| 表示顶点的数量（|V| ≥ 1），用 |E| 表示边的数量（|E| ≥ 0）。

![1597931899188](../../../../../../img/in-post/2020-09-18-数据结构/1597931899188.png)

![1597931908711](../../../../../../img/in-post/2020-09-18-数据结构/1597931908711.png)

![1597931928859](../../../../../../img/in-post/2020-09-18-数据结构/1597931928859.png)

![1597931945118](../../../../../../img/in-post/2020-09-18-数据结构/1597931945118.png)

![1597932164512](../../../../../../img/in-post/2020-09-18-数据结构/1597932164512.png)

![1597932292507](../../../../../../img/in-post/2020-09-18-数据结构/1597932292507.png)

![1597932346365](../../../../../../img/in-post/2020-09-18-数据结构/1597932346365.png)

## 图的表示 ##

### 邻接矩阵 ###

![1597932552632](../../../../../../img/in-post/2020-09-18-数据结构/1597932552632.png)

![1597932572493](../../../../../../img/in-post/2020-09-18-数据结构/1597932572493.png)

```c
#define MaxVertexNum 100/* 最大顶点数设为100 */
#define INFINITY 65535/* ∞设为双字节无符号整数的最大值65535*/
typedef int Vertex;/* 用顶点下标表示顶点,为整型 */
typedef int WeightType;/* 边的权值设为整型 */
typedef char DataType;/* 顶点存储的数据类型设为字符型 */

/* 边的定义 */
typedef struct ENode* PtrToENode;
struct ENode{
	Vertex V1,V2;/* 有向边<V1, V2> */
	WeightType Weight;/* 权重 */
}; 
typedef PtrToENode Edge;

/* 图结点的定义 */
typedef struct GNode* PtrToGNode;
struct GNode{
	int Nv;/* 顶点数 */
	int Ne;/* 边数   */
	WeightType G[MaxVertexNum][MaxVertexNum];/* 邻接矩阵 */
	DataType Data[MaxVertexNum]; /* 存顶点的数据 */
	/* 注意：很多情况下，顶点无数据，此时Data[]可以不用出现 */
};
typedef PtrToGNode MGraph; /* 以邻接矩阵存储的图类型 */
```

### 邻接表 ###

![1597932656274](../../../../../../img/in-post/2020-09-18-数据结构/1597932656274.png)

![1597932825127](../../../../../../img/in-post/2020-09-18-数据结构/1597932825127.png)

```c
/* 边的定义 */
typedef struct ENode *PtrToENode;
struct ENode{
    Vertex V1,V2;/* 有向边<V1, V2> */
    WeightType Weight;/* 权重 */
};
typedef PtrToENode Edge;

/* 邻接点的定义 */
typedef struct AdjVNode *PtrToAdjVNode;
struct AdjVNode{
	Vertex AdjV;/* 邻接点下标 */
	WeightType Weight;/* 边权重 */
    PtrToAdjVNode Next;/* 指向下一个邻接点的指针 */
};

/* 顶点表头结点的定义 */
/*定点下标是数组下标，不用写在结构里*/
typedef struct Vnode{
	PtrToAdjVNode FirstEdge;/* 边表头指针 */
	DataType Data;/* 存顶点的数据 */
	/* 注意：很多情况下，顶点无数据，此时Data可以不用出现 */
}AdjList[MaxVertexNum]; /* AdjList是邻接表类型 */
//用typedef 是说AdjList 就是这个结构数组！！！
 
/* 图结点的定义 */
typedef struct GNode *PtrToGNode;
struct GNode{
	int Nv;/* 顶点数 */
	int Ne;/* 边数   */
	AdjList G; /* 邻接表 *///G结构数组 
};
typedef PtrToGNode LGraph; /* 以邻接表方式存储的图类型 */
```

## 图的遍历 ##

### 深度优先搜索DFS ###

![1598088381913](../../../../../../img/in-post/2020-09-18-数据结构/1598088381913.png)

```c
/* Visited[]为全局变量，已经初始化为false */
void DFS(LGraph Graph,Vertex V)
{/* 以V为出发点对邻接表存储的图Graph进行DFS搜索 */
	Visit(V);/* 访问第V个顶点 */
	Visited[V]=true;/* 标记V已访问 */
	for(PtrToAdjVNode W=Graph->G[V].FirstEdge;W;W=W->Next){/* 对V的每个邻接点W->AdjV */
		if(!Visited[W->AdjV]){/* 若W->AdjV未被访问 */
			DFS(Graph,W->AdjV);/* 则递归访问之 */
		}
	}	
} 
```

### 广度优先搜索BFS ###

复杂度通DFS。即O(V^2)或者O(V+E)

```c
/* Visited[]为全局变量，已经初始化为false */
void BFS(MGraph Graph,Vertex S)
{/* 以S为出发点对邻接矩阵存储的图Graph进行BFS搜索 ,void(*Visit)(Vertex)*/
	Queue Q = CreateQueue();/* 创建空队列, MaxSize为外部定义的常数 */
	/* 访问顶点S：此处可根据具体访问需要改写 */
	Visit(S);
	Visited[S]=true;
	AddQ(Q,S);
	while(!IsEmpty(Q)){
		Vertex V = DeleteQ(Q);
		for(Vertex W=0;W<Graph->Nv;W++){/* 对图中的每个顶点W */
			/* 若W是V的邻接点并且未访问过 */
			if(!Visited[W] && IsEdge(Graph,V,W)){
				/* 访问顶点W */
				Visit(W);
				Visited[W]=true;
				AddQ(Q,W);
			}
		}
	}
}
```

## 最小生成树MST ##

### Prim算法 ###

邻接矩阵O(V^2)

邻接表+堆优化O(ElogV)

#### 朴素实现 ####

```c
struct node {
    int weight;
    int id;
    node(int weight, int id) : weight(weight), id(id) {}
};

vector<node> g[5005]; //邻接表
int dist[5005]; //最短距离 同时也是标记 收录的点dist=0

int findmin(int n) {  //找没有被收录的最小距离的点 O(N)
    int mind = 2147483647;
    int minv = 0;
    for (int i=1;i<=n;i++) {
        if (dist[i]) {
            if (dist[i] < mind) {
                mind = dist[i];
                minv = i;
            }
        }
    }
    if (mind != 2147483647) {  return minv; }
    else {  return -1; }
}

void Prim(int e, int n) {  //以e为初始点 构建最小生成树
    //初始化距离为到e的距离
    for (int i=1;i<=n;i++) {
        dist[i] = 2147483647;  //先初始为最大值，之后跟e临接的点再改成到e的距离
    }
    for (int i=0;i<g[e].size();i++) {
    	//考虑到两点之间可以有重边 距离应该是最小的那个 
        dist[g[e][i].id]=min(g[e][i].weight, dist[g[e][i].id]);  //在更新e的邻接点的距离
    }
    int cnt = 0;  //记录收录的点的个数
    int ans = 0;  //记录总的权重
    //收录根节点  也就是距离设为0 
    dist[e] = 0;
    cnt++;
    while (1) {
        int t = findmin(n);
        if (t == -1) {  //没有点了 就结束
            break;
        }
        //收录这个点t
        ans += dist[t];  //dist[t]是点t到达最小生成树的距离
        dist[t] = 0; 
        cnt++;
        if (cnt == n) {  //收录了n个点break
            break;
        }
        //把点t收录之后，会对其他点（t的邻接点）的距离造成影响
        for (int i=0;i<g[t].size();i++) { //访问邻接点
            int id = g[t][i].id;  //邻接点id
            int we = g[t][i].weight;  //到邻接点的距离
            if (dist[id]) {  //没有收录过的邻接点
                if (dist[id] > we) {  //更新距离 dist[id]是点id到树的距离 we是t和id的距离
                    dist[id] = we;
                }
            }
        }
    }
    //判断一下是否把全部n个点都收录了
    if (cnt == n) {
    	cout << ans << endl;
	}
	else {
		cout << "orz" << endl;
	}
}
```

#### 堆优化 ####

邻接表+堆优化O(E*logV)

```c
struct node {
    int weight;
    int id;
    node(int weight, int id) : weight(weight), id(id) {}
    bool operator< (const node t) const {
        return weight > t.weight; //优先队列 从小到大
    }
};

vector<node> g[5005]; //邻接表
int dist[5005]; //最短距离 也是一种标记 dist=0说明被收录了

void Prim(int e, int n) {  //以e为初始点 构建最小生成树
    priority_queue<node> que;
    //初始化成较大值 不是初始化成到根节点的距离
    for (int i=1;i<=n;i++) {
        dist[i] = 2147483647;  //先初始为最大值
    }
    int cnt = 0;  //记录收录的点的个数
    int ans = 0;
    //暂不收录根节点 只是压入队列 先不标记dist
    que.push(node(0, e));
    while (!que.empty()) {
    	//开始没有收录根节点 所以会在这出来 接着找根的邻接点
		//尝试着更新距离 压入队列 所以初始化dist为较大值 
        node tmp = que.top();
        que.pop();
        if (!dist[tmp.id]) {  //已经被收录了 看下一个
            continue;
        }
        //收录这个点 距离设为0 计数
        ans += tmp.weight; //tmp.weight是点tmp.id到达最小生成树的距离
        dist[tmp.id] = 0; 
        cnt++;
        if (cnt == n) {  //收录了n个点 结束 不可以删，因为有同一个顶点，不同距离在队列中
            break;
        }
        for (int i=0;i<g[tmp.id].size();i++) { //访问邻接点
            int id = g[tmp.id][i].id;  //邻接点id
            int we = g[tmp.id][i].weight;  //到邻接点的距离
            if (dist[id]) {  //没有收录过的邻接点
                if (dist[id] > we) {  //更新距离 dist[id]是点id到树的距离 we是t和id的距离
                    dist[id] = we;
                    que.push(node(dist[id], id));  //压入队列
                }
            }
        }
    }
    if (cnt == n) {
    	cout << ans << endl;
	}
	else {
		cout << "orz" << endl;
	}
}
```

###  Kruskal算法 ###

O(E*logV) 

从小到大收录边，使用最小堆依次弹出边。

对于每条边，使用并查集验证是否成环，不成环则收录进去。

也可以先用快排对边进行排序，然后按顺序使用并查集处理即可。

```c
typedef struct ENode *PtrToENode;
struct ENode{
    Vertex V1,V2;/* 有向边<V1, V2> */
    WeightType Weight;/* 权重 */
};
typedef PtrToENode Edge;

int Kruskal(LGraph Graph,LGraph MST)
{/* 将最小生成树保存为邻接表存储的图MST，返回最小权重和 */
	WeightType TotalWeight;
	int ECount,NextEdge;
	SetType VSet;/* 顶点数组 */
	Edge ESet;/* 边数组 */
	
	InitializeVSet(VSet,Graph->Nv); /*初始化顶点并查集 */
	ESet=(Edge)malloc(sizeof(struct ENode)*Graph->Ne);
	InitializeESet(Graph,ESet); /*初始化边的最小堆 */
	
	/* 创建包含所有顶点但没有边的图。注意用邻接表版本 */
	//MST=CreateGraph(Graph->Nv);临时空间 局部变量 退出函数会被释放掉 
	TotalWeight=0;
	ECount=0;
	
	NextEdge=Graph->Ne; /* 原始边集的规模 */
	//NextEdge并不是指针，只是最小边的数组下标，ESet[NextEdge]是最小边 
	while(ECount<Graph->Nv-1){/* 当收集的边不足以构成树时 */
		NextEdge=GetEdge(ESet,NextEdge);/* 从边集中得到最小边的位置 */
		if(NextEdge<0)/* 边集已空 */
			break;
		/* 如果该边的加入不构成回路，即两端结点不属于同一连通集 */
		if(CheckCycle(VSet,ESet[NextEdge].V1,ESet[NextEdge].V2)==true)
		{ /* 将该边插入MST */
			InsertEdge(MST,ESet+NextEdge);  //V2加入V1邻接表 V1加入V2邻接表
			TotalWeight+=ESet[NextEdge].Weight;/* 累计权重 */
			ECount++;/* 生成树中边数加1 */
		}
	}
	//边数<n-1 说明够不成生成树
	if(ECount<Graph->Nv-1){
		TotalWeight=-1;/* 设置错误标记，表示生成树不存在 */
	}
	return TotalWeight;
} 

int GetEdge(Edge ESet,int CurrentSize)  //最小堆的删除操作O(logE)
{/* 给定当前堆的大小CurrentSize，将当前最小边位置弹出并调整堆 */
	/* 将最小边与当前堆的最后一个位置的边交换 */
	struct ENode e;
	e=ESet[0];
	ESet[0]=ESet[CurrentSize-1];
	ESet[CurrentSize-1]=e;
	/* 将剩下的边继续调整成最小堆 */
	PercDown(ESet,0,CurrentSize-1);	
	return CurrentSize-1;/* 返回最小边所在位置 */
}

int CheckCycle(SetType VSet,Vertex V1,Vertex V2)  //并查集O(logV)
{/* 检查连接V1和V2的边是否在现有的最小生成树子集中构成回路 */
	Vertex Root1,Root2;
	Root1=Find(VSet,V1);/* 得到V1所属的连通集名称 */
	Root2=Find(VSet,V2);/* 得到V2所属的连通集名称 */
	if(Root1==Root2){/* 若V1和V2已经连通，则该边不能要 ,要的话就会出现回路*/
		return false;
	}else{/* 否则该边可以被收集，同时将V1和V2并入同一连通集 */
		Union(VSet,Root1,Root2);
		return true;
	} 
} 
```

## 最短路问题 ##

### Dijkstra算法 ###

单源最短路，不能有负值边。

邻接矩阵O(V^2)

邻接表+堆优化O(ElogV)

#### 朴素实现 ####

```c
struct node {
    int weight;
    int id;
    node(int weight, int id) : weight(weight), id(id) {}
};

vector<node> g[10005]; //邻接表
int vis[10005];  //标记位 
int dist[10005]; //最短距离 

int findmin(int n) {  //找没有被标记过的最小距离的点 O(N) 
    int mind = 2147483647;
    int minv = 0;
    for (int i=1;i<=n;i++) {
        if (!vis[i]) {
            if (dist[i] < mind) {
                mind = dist[i];
                minv = i;
            }
        }
    }
    if (mind != 2147483647) {
        return minv;
    }
    else {
        return -1;
    }
}

void dijkstra(int e, int n) {
    for (int i=1;i<=n;i++) {
        dist[i] = 2147483647;
    }
	//注意根节点距离设为0 但是不要标记vis
    dist[e] = 0;
    while (1) {
        int t = findmin(n);
        if (t == -1) {  //没有点了 就结束 
            break;
        }
        //访问这个点 
        vis[t] = 1;
        for (int i=0;i<g[t].size();i++) { //访问邻接点 
            int id = g[t][i].id;  //邻接点id 
            int we = g[t][i].weight;  //到邻接点的距离 
            //if (!vis[id]) {  //没有访问过的邻接点 如果是访问过的点，dist[id]已经是最小的，所以执行下边的比较也没关系
                if (dist[id] > we + dist[t]) {  //更新距离 
                    dist[id] = we + dist[t];
                }
            //}
        }
    }
}
```

#### 堆优化 ####

邻接表+堆优化O(E*logV)

```c
struct node {
    int weight;
    int id;
    node(int weight, int id) : weight(weight), id(id) {}
    bool operator < (const struct node t) const {
        return weight > t.weight; //优先队列 从小到大
    }
};

vector<node> g[100005]; //邻接表
int vis[100005];  //标记位
int dist[100005]; //最短距离

void dijkstra(int e) {
    priority_queue<node> que;
    for (int i=1;i<=n;i++) {
        dist[i] = 2147483647;
    }
    //注意根节点入队 距离设为0 但是不要标记vis
    dist[e] = 0;
    que.push(node(0, e));
    while (!que.empty()) {
        node tmp = que.top();
        que.pop();
        if (vis[tmp.id]) { //访问过就看下一个
            continue;
        }
        //访问这个点
        vis[tmp.id] = 1;
        for (int i=0;i<g[tmp.id].size();i++) {  //访问邻接点
            int id = g[tmp.id][i].id;  //邻接点id
            int we = g[tmp.id][i].weight;  //到邻接点的距离
            //if (!vis[id]) {  //没有访问过的邻接点 如果是访问过的点，dist[id]已经是最小的，所以执行下边的比较也没关系
                if (dist[id] > we + dist[tmp.id]) {
                    dist[id] = we + dist[tmp.id];  //更新距离
                    que.push(node(dist[id], id));  //压入队列
                }
            //}
        }
    }
}
```

### Floyd算法 ###

多源最短路 O(V^3)

```c
/* 邻接矩阵存储 - 多源最短路算法 */
int Floyd(MGraph Graph,WeightType D[][MaxVertexNum],Vertex path[][MaxVertexNum])
{
	Vertex i,j,k;
	//初始化
	for(i=0;i<Graph->Nv;i++){
		for(j=0;j<Graph->Nv;j++){
			D[i][j]=Graph->G[i][j];
			path[i][j]=-1;
		}
	} 
	for(k=0;k<Graph->Nv;k++){ //k在最外层，遍历对角线 
		for(i=0;i<Graph->Nv;i++){
			for(j=0;j<Graph->Nv;j++){
				if(D[i][k]+D[k][j]<D[i][j]){
					D[i][j]=D[i][k]+D[k][j];
					if(i==j&&D[i][j]<0){/* 若发现负值圈 */
						return false;/* 不能正确解决，返回错误标记 */
					}
					path[i][j]=k; 
				}
			}
		}
	}
	return true; /* 算法执行完毕，返回正确标记 */
} 
```

## 拓扑排序 ##

“有向无环图”（Directed Acyclic Graph，DAG）

拓扑排序是指有向无环图中各顶点构成的有序序列。该序列满足如下条件：如果图中一顶点v<sub>i</sub>到另一顶点v<sub>j</sub>存在一条路径，那么v<sub>j</sub>在此图的拓扑排序序列中位于v<sub>i</sub>之后。

![1598093240707](../../../../../../img/in-post/2020-09-18-数据结构/1598093240707.png)

复杂度O(V^2)

![1598093270036](../../../../../../img/in-post/2020-09-18-数据结构/1598093270036.png)

![1598093182892](../../../../../../img/in-post/2020-09-18-数据结构/1598093182892.png)

复杂度O(V+E)

```c
/* 邻接表存储 - 拓扑排序算法---一定是有向图 */
int TopSort(LGraph Graph,Vertex TopOrder[])
{/*对Graph进行拓扑排序,TopOrder[]顺序存储排序后的顶点下标 */
	int Indegree[MaxVertexNum];//入度
	Queue Q=CreateQueue(Graph->Nv);
	
	/* 初始化Indegree[] */
	for(Vertex V=0;V<Graph->Nv;V++){
		Indegree[V]=0;
	} 
	/* 遍历图，得到Indegree[] */
	for(Vertex V=0;V<Graph->Nv;V++){//邻接表存储 
		for(PtrToAdjVNode W=Graph->G[V].FirstEdge;W;W=W->Next){
			Indegree[W->AdjV]++;/* 对有向边<V, W->AdjV>累计终点的入度 */
		}
	}
	
	/* 将所有入度为0的顶点入列 */
	for(Vertex V=0;V<Graph->Nv;V++){
		if(Indegree[V]==0){
			AddQ(Q,V);
		}
	} 
	
	/* 下面进入拓扑排序 */ 
	int cnt=0;
	while(!IsEmpty(Q)){
		Vertex V=DeleteQ(Q);/* 弹出一个入度为0的顶点 */
		TopOrder[cnt]=V;/* 将之存为结果序列的下一个元素 */
		cnt++;
		/* 对V的每个邻接点W->AdjV */
		for(PtrToAdjVNode W=Graph->G[V].FirstEdge;W;W=W->Next){
			Indegree[W->AdjV]--;//删除V，相当于V的邻接点入度-1
			if(Indegree[W->AdjV]==0){/* 若删除V使得W->AdjV入度为0 */
				AddQ(Q,W->AdjV);/* 则该顶点入队 */
			} 
		}
	}
	
	if(cnt!=Graph->Nv){//点的个数不够-队列空了（没有入度为0的点了）但是还有点没加进来，说明有环 
		return false;/* 说明图中有回路, 返回不成功标志 */ 
	}else{
		return true;
	}
} 
```

# 散列 #

形如“名字(Name)-属性(Attribute)”对的集合的“符号表(Symbol Table)”也叫做“**散列表**” （Hash Table，即**哈希表**）

“散列（Hashing）” 的基本思想是：以数据对象的关键字key为自变量，通过一个确定的函数关系 h，计算出对应的函数值h(key)，把这个值解释为数据对象的存储地址，并按此存放，即“存储位置 = h（key）”。

在查找某数据对象时，用同样的方法“存储位置 = h（key）”计算出地址，将key与该地址单元中数据对象关键字进行比较，确定查找是否成功。

可能将不同的关键字映射到同一个散列地址上，即h(keyi) = h(keyj)（当keyi ≠keyj），这种现象称为“**冲突**(Collision)”， keyi 和keyj称为“同义词（synonym）”

通常关键词的值域（允许取值的范围）远远大于表空间的地址集，所以说，**冲突不可能避免，只能尽可能减少**。

## 散列函数 ##

![1597846138210](../../../../../../img/in-post/2020-09-18-数据结构/1597846138210.png)

![1597846192202](../../../../../../img/in-post/2020-09-18-数据结构/1597846192202.png)

![1597846215790](../../../../../../img/in-post/2020-09-18-数据结构/1597846215790.png)

![1597846303546](../../../../../../img/in-post/2020-09-18-数据结构/1597846303546.png)

## 冲突处理 ##

### 开放地址法 ###

![1597846522309](../../../../../../img/in-post/2020-09-18-数据结构/1597846522309.png)

```c
/* 散列单元状态类型，分别对应：有合法元素、空单元、有已删除元素 */
typedef enum{
	Legitimate, 
	Empty,
	Deleted,
} EntryType; 

//散列表的每个单元既有数据的值，又要有数据的状态，所以用结构体
//删除的元素不能直接删除，只能假删除
typedef struct HashEntry Cell;/* 散列表单元类型 */
struct HashEntry{
	ElementType Data;/* 存放元素 */
	EntryType Info; /* 单元状态 */
};

typedef struct TblNode* HashTable;/* 散列表类型 */
struct TblNode{/* 散列表结点定义 */
	int TableSize; /* 表的最大长度 */
	Cell* Cells;   /* 存放散列单元数据的数组 */
};
```

#### 线性探测法 ####

遇到冲突就+1

“一次聚集（Primary Clustering）”现象：需要经过很多次冲突才找到空位置。

![1597846641133](../../../../../../img/in-post/2020-09-18-数据结构/1597846641133.png)

![1597846837899](../../../../../../img/in-post/2020-09-18-数据结构/1597846837899.png)

#### 平方探测法 ####

平方探测法以增量序列**1\^2，-1\^2，2\^2，-2\^2，…，q\^2，-q\^2**且q ≤ TableSize/2的下取整，循环试探下一个存储地址。

**如果散列表长度TableSize是某个4k+3（k是正整数）形式的素数时，平方探测法就可以探查到整个散列表空间。**

二次聚集（Secondary Clustering） ”现象：散列到同一地址的那些数据对象将探测相同的备选单元。【比如下例子中的7、29、84】

![1597847110979](../../../../../../img/in-post/2020-09-18-数据结构/1597847110979.png)

插入29，+1不冲突

插入84，+1冲突，-1不冲突

插入20，+1，-1都冲突，+4不冲突

插入30，+1，-1都冲突，+4不冲突

**在开放地址散列表中，删除操作要很小心。通常只能“懒惰删除”，即需要增加一个“删除标记(Deleted)”，而并不是真正删除它。以便查找时不会“断链”。其空间可以在下次插入时重用。**

##### 初始化 #####

```c
HashTable CreateTable(int TableSize)
{
	HashTable H;
	H=(HashTable)malloc(sizeof(struct TblNode));
	/* 保证散列表最大长度是素数 */
	H->TableSize=NextPrime(TableSize);
	/* 声明单元数组 */
	H->Cells=(Cell*)malloc(sizeof(Cell)*H->TableSize);
	/* 初始化单元状态为"空单元"*/
	int i;
	for(i=0;i<H->TableSize;i++){
		H->Cells[i].Info=Empty;
	}
	return H;
}
```

##### 查找 #####

先求初始的散列位置，若此处为空，说明该值不存在。

若不为空，此处等于Key则找到。

若不为空，此处不等于Key则开始向两边探测，求出新位置之后，重复上述过程。

返回值是找到了Key的位置或者是没找到的空位置（也是Key应该放的位置），可以**根据该位置存储的状态信息判断是什么情况。若为Legitimate则说明是找到了。**

```c
Position Find(HashTable H,ElementType Key)
{
	int CNum=0;/* 记录冲突次数 */
	Position New;
	Position Current;
	New=Current=Hash(Key,H->TableSize);/* 初始散列位置 */
	
	/* 当该位置的单元非空，并且不是要找的元素时，发生冲突 */
	while(H->Cells[New].Info!=Empty&&H->Cells[New].Data!=Key){/* 字符串类型的关键词需要 strcmp 函数!! */
		/* 统计1次冲突，并判断奇偶次 */						
		if(++CNum%2){/* 奇数次冲突 */
			New=Current+(CNum+1)*(CNum+1)/4;//+i^2
			if(New>=H->TableSize){//加之后下标超出合理范围 
				New%=H->TableSize;/* 调整为合法地址 */
			} 
		}else{ /* 偶数次冲突 */
			New=Current-CNum*CNum/4;//-i^2
			while(New<0){//减之后下标小于0 
				New+=H->TableSize;/* 调整为合法地址 */
			}
		} 
	}
	return New; /*此时New或者是Key的位置，或者是一个空单元的位置（表示找不到）*/
}
```

##### 插入 #####

调用Find，未找到则插入到Find返回的位置中

```c
int Insert(HashTable H,ElementType Key)
{
	Position Pos=Find(H,Key);/* 先检查Key是否已经存在 */
	if(H->Cells[Pos].Info!=Legitimate){/* 如果这个单元没有被占---New是一个空地址，说明Key可以插入在此 */
		H->Cells[Pos].Info=Legitimate;
		H->Cells[Pos].Data=Key;
		/*字符串类型的关键词需要 strcpy 函数!! */
		return 1;
	}
	else{ //Find返回值New位置存的就是Key--在表里找到了你想插入的元素，不用再插入了 
		printf("键值已存在\n");
		return 0;
	}
} 
```

##### 删除 #####

调用Find，找到了则**假删除**，标记状态为Deleted

```c
int Delete(HashTable H,ElementType Key)
{
	Position Pos=Find(H,Key);/* 先检查Key是否已经存在 */
	if(H->Cells[Pos].Info!=Legitimate){
		printf("没找到该值\n");
		return 0;
	}
	else{ //Find返回值New位置存的就是Key--在表里找到了你想删除的元素
		H->Cells[Pos].Info=Deleted;
		return 1; 
	}
}
```

#### 双散列探测法 ####

![1597847486562](../../../../../../img/in-post/2020-09-18-数据结构/1597847486562.png)

#### 再散列 ####

![1597847581463](../../../../../../img/in-post/2020-09-18-数据结构/1597847581463.png)


### 分离链接法 ###

将所有关键词为同义词的数据（有冲突的数据）对象通过结点链接存储在同一个单链表中。

```c
typedef char ElementType[KEYLENGTH+1];/* 关键词类型用字符串 */

typedef struct LNode* PtrToLNode;
struct LNode{
	ElementType Data;//字符数组 
	PtrToLNode Next; 
};
typedef PtrToLNode Position;
typedef PtrToLNode List;

typedef struct TblNode* HashTable;/* 散列表类型 */
struct TblNode{/* 散列表结点定义 */
	int TableSize; /* 表的最大长度 */
	struct LNode* Heads; /* 指向链表头结点的数组 */
};
```

#### 初始化 ####

```c
HashTable CreateTable(int TableSize)
{
	HashTable H;
	H=(HashTable)malloc(sizeof(struct TblNode));
	H->TableSize=NextPrime(TableSize);
	
	/* 以下分配链表头结点数组 */
	H->Heads=(List)malloc(sizeof(struct LNode)*H->TableSize);
	/* 初始化表头结点 */
	int i;
	for(i=0;i<H->TableSize;i++){
		H->Heads[i].Data[0]='\0';
		H->Heads[i].Next=NULL;
	}
	return H;
} 
```

#### 查找 ####

通过散列函数求出位置，然后遍历对应的那个链表。

```c
Position Find(HashTable H,ElementType Key)
{
	Position p;
	Index Pos=Hash(Key,H->TableSize);/* 初始散列位置 */
	p = H->Heads[Pos].Next; /* 从该链表的第1个结点开始 */
	/* 当未到表尾，并且Key未找到时 */
	while(p&&strcmp(p->Data,Key)){
		p=p->Next;
	}
	return p; /* 此时P或者指向找到的结点，或者为NULL */
}
```

#### 插入 ####

先要查找看待插入元素在不在散列表中，在的话什么都不做。

不在的话，通过散列函数求出位置，找到对应的那个链表，采用**头插法**，速度快。

```c
int Insert(HashTable H,ElementType Key)
{
	Position p=Find(H,Key);
	if(!p){ /* 关键词未找到p==NULL，可以插入 */
		Position New;
		New=(Position)malloc(sizeof(struct LNode));
		strcpy(New->Data,Key);
		//找一下插在哪个链表 
		Index Pos=Hash(Key,H->TableSize);/* 初始散列位置 */
		/* 将New插入为H->Heads[Pos]链表的第1个结点 */
		New->Next=H->Heads[Pos].Next;
		H->Heads[Pos].Next=New;
		return 1; 
	}
	else{ //Find返回值New位置存的就是Key--在表里找到了你想插入的元素，不用再插入了 
		printf("键值已存在\n");
		return 0;
	}
} 
```

#### 删除 ####

先要查找看待插入元素在不在散列表中，不在的话就不能删除。

在的话，通过散列函数求出位置，找到对应的那个链表，遍历链表，找到对应的节点删除它。

```c
int Delete(HashTable H,ElementType Key)
{
	Position p=Find(H,Key);
	if(!p){/* 关键词未找到p==NULL */
		printf("没找到该值\n");
		return 0;
	}else{ //Find返回值New位置存的就是Key--在表里找到了
		//找一下在哪个链表 
		Index Pos=Hash(Key,H->TableSize);/* 初始散列位置 */
		Position Tmp=H->Heads[Pos].Next;
		if(p!=H->Heads[Pos].Next){  //说明需要删除的点不是第一个节点
			while(Tmp->Next!=p){
				Tmp=Tmp->Next;//找P的前驱节点 
			}  //直到Tmp->Next=p
			Tmp->Next=p->Next;  //把p跳过去即可
		}
		else{  //p==H->Heads[Pos].Next说明需要删除的点是第一个节点
			H->Heads[Pos].Next=p->Next;  //把p跳过去即可
		}
		free(p);
	}
}
```

#### 释放表 ###

```c
void DestroyTable(HashTable H)
{
	int i;
	Position P,Tmp;
	/* 释放每个链表的结点 */
	for(i=0;i<H->TableSize;i++){
		P=H->Heads[i].Next;
		while(P){
			Tmp=P->Next;
			free(P);
			P=Tmp;
		}
	}
	free(H->Heads); /* 释放头结点数组 */
	free(H);/* 释放散列表结点 */
}
```

## 性能分析 ##

![1597847705434](../../../../../../img/in-post/2020-09-18-数据结构/1597847705434.png)

![1597847724324](../../../../../../img/in-post/2020-09-18-数据结构/1597847724324.png)

![1597847733934](../../../../../../img/in-post/2020-09-18-数据结构/1597847733934.png)

![1597847765812](../../../../../../img/in-post/2020-09-18-数据结构/1597847765812.png)

## 对比 ##

![1597847891112](../../../../../../img/in-post/2020-09-18-数据结构/1597847891112.png)

![1597847906681](../../../../../../img/in-post/2020-09-18-数据结构/1597847906681.png)

# 排序 #

## 选择排序 ##

每次选择最小的元素，交换到前边。外循环做n-1次，每次内循环查找一个最小值，然后交换。

**选择排序不是稳定排序**，因为每次是选择最小的，跟最前边的交换，就可能把前边的交换到后边去了。例如5,9,5,2，第一最小的是2和第一个5交换，就会导致第一个5变到第二个5后边去了。

```c
/*选择排序*/
void Select_Sort(int a[],int n)
{
	int i,j,min;
	for(i=0;i<n-1;i++){
		min=i;
		for(j=i+1;j<n;j++){/*寻找最小元素*/
			if(a[j]<a[min]){
				min=j; /*min记录最小元素*/ 
			}
		}
		int tmp=a[i];/*交换*/ 
		a[i]=a[min];
		a[min]=tmp;
	} 
}
```

## 堆排序 ##

优化选择排序，不需要遍历去找最小值，而是使用堆来找最大/小值。

**n个数构建最大/小堆的算法是O(n)的。**

【一种朴素的方法是：构成最小堆之后，每次弹出最小值，弹出n次，即有序】

算法：构建最大堆后，交换堆顶（最大值）和最后一个元素（第n个），然后开始从堆顶下滤，把前n-1个元素恢复成最大堆，重复上述过程。（交换了n-1次，下滤了n-1次）

**堆排序不是稳定排序**

![1597927029659](../../../../../../img/in-post/2020-09-18-数据结构/1597927029659.png)

```c
/*堆排序*/
void Heap_Sort(int a[],int n)
{
	int i;
	for(i=n/2-1;i>=0;i--){/* 建立最大堆 */
		PercDown(a,i,n);
	}

	for(i=n-1;i>0;i--){
		/* 删除最大堆顶 */
		Swap(&a[0],&a[i]);
		PercDown(a,0,i);//把0位根节点调成最大堆,堆(删除最大元素后)的大小是i，i是取不到的位置 
	}	
}

void PercDown(int a[],int p,int n)  //参数n代表堆的大小
{/* 下滤：将H中以H->Data[p]为根的子堆调整为最大堆 */
	ElementType X;
	X=a[p]; /* 取出根结点存放的值 */
	
	int Parent,Child;//下标从0开始，左儿子是Parent*2+1，n是取不到的位置 
	for(Parent=p;(Parent*2+1)<n;Parent=Child){
		Child=Parent*2+1;
		if((Child!=n-1)&&(a[Child+1]>a[Child])){
			Child++;
		}
		if(X>=a[Child]){
			break;
		}
		else{
			a[Parent]=a[Child];
		}
	}
	a[Parent]=X;	
}
```

## 插入排序 ##

i前边都是有序的，a[i]跟前边比，插入到合适的位置。

过程如下：a[0]及之前有序的，a[1]跟a[0]比，插入之后a[1]及之前都有序了；a[2]跟a[1]、a[0]比，插入之后a[2]之前都有序了…..【a[2]<a[1]，a[1]要向后移，a[2]向前移跟a[0]比，a[2]<a[0]，a[0]向后移；a[2]>=a[0]，a[2]就找到了合适的位置】

外循环遍历1->n-1，内循环从后向前找合适的位置，可能需要数组元素的向右移动。

最坏情况：原序列是倒序 O(n^2)

最坏情况：原序列是正序 O(n)

**插入排序是稳定排序**

```c
/* 插入排序 */
void Insert_Sort(int a[],int n)
{
	int p;
	for(p=1;p<n;p++){
		int tmp=a[p];/*取出未排序序列中的第一个元素*/
		int i;
		for(i=p;i>=1&&a[i-1]>tmp;i--){
			a[i]=a[i-1];/*依次与已排序序列中元素比较并右移*/
		}
		a[i]=tmp;/*放进合适的位置 */
	}
} 
```

## 希尔排序 ##

希尔排序是n-间隔的插入排序。

希尔排序算法的整体时间复杂度和增量序列的选取有关，目前并没有统一的最优增量序列。

当使用增量序列 { ⌊N/2⌋,  ⌊N/2^2⌋ , …,  1} 进行希尔排序时，最差情况下的时间复杂度  T<sub>worst</sub>(n) = O(N^2)；

当使用增量序列 { 2<sup>k</sup>-1,…, 7, 3,1 } 时，最差情况下时间复杂度为 T<sub>worst</sub>(n) =  O(N<sup>3/2</sup>)，平均时间复杂度为T<sub>average</sub>(n) = O(N<sup>5/4</sup>)。

**希尔排序不是稳定排序**

```c
/* 希尔排序 - 用Sedgewick增量序列 */
void Shell_Sort(int a[],int n)
{
	/* 这里只列出一小部分增量 */
	int Sedgewick[]={929,505,209,109,41,19,5,1,0};
	
	int si;
	for(si=0;Sedgewick[si]>=n;si++)
		; /* 初始的增量Sedgewick[Si]不能超过待排序列长度 */
	
	int D,i,p;
	for(D=Sedgewick[si];D>0;D=Sedgewick[++si]){
		for(p=D;p<n;p++){ /* 插入排序*/
			int tmp=a[p];
			for(i=p;i>=D&&a[i-D]>tmp;i-=D){
				a[i]=a[i-D];
			}
			a[i]=tmp;
		}
	}
} 
```

## 冒泡排序 ##

每次冒泡是比较a[i]和a[i+1]，把大的交换到后边，从头冒到尾，就会把最大的值交换到最后。

外层循环n-1次，内层做一次从前到后的冒泡即可。**如果一次过程中没发生交换，可以提前结束算法。**

**冒泡排序是稳定排序**

```c
/*冒泡排序*/
void Bubble_Sort(int a[],int n)
{
	int p,i;
	for(p=n-1;p>0;p--){  //p相当于冒泡的结尾，因为p之后的都排好序了，不用再去比较了。
		int flag=0;
		for(i=0;i<p;i++){/*一趟冒泡*/
			if(a[i]>a[i+1]){
				int tmp;
				tmp=a[i];
				a[i]=a[i+1];
				a[i+1]=tmp;
				flag=1; /*标识发生了交换*/
			}
		}
		if(flag==0) break; /*全程无交换*/
	}
} 
```

## 快速排序 ##

设置一个基准e，把比e小的都交换到前边，比e大的都交换到后边，然后放入e。此时e就是他应该在的位置。之后递归的处理e的左右两边。**快速排序每一轮都能把一个元素放在他最后应该在的位置。**

**快速排序不是稳定排序**

```c
void qsort(int v[ ],int left, int right)
{
    int i, j,last;
    if(left >= right) return;
    swap(&v[left], &v[(left+right)/2]); //move partition elem to v[0] 
    i=left;
    j=right+1;
    while(1) {
    	while(v[++i]<v[left]){}  //a[i]>=pri
		while(v[--j]>v[left]){}  //a[j]<=pri
		if(i<j){
			swap(&v[i],&v[j]);
		}
		else{
			break;
		}
	}
    //i>=j了，a[j]<=a[left]，所以跟a[j]互换，把a[j]换到a[left]，因为a[j]小于a[left]
	swap(&v[j],&v[left]);
    qsort(v, left, j-1);  
    qsort(v, j+1, right);
}
```

## 归并排序 ##

主要思想是将左右两个已排序的子序列合并成一个有序序列，合并时间O(N)。

**归并排序是稳定排序**

### 递归实现 ###

```c
/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/ 
void Merge(int a[],int tmpA[],int L,int R,int RightEnd)
{
	/* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */
	int LeftEnd=R-1;/* 左边终点位置 */
	int tmp=L;/* 有序序列的起始位置 */
	int num=RightEnd-L+1;//个数 
    
	while(L<=LeftEnd&&R<=RightEnd){
		if(a[L]<a[R]){
			tmpA[tmp++]=a[L++];/* 将左边元素复制到TmpA */
		}else{
			tmpA[tmp++]=a[R++];/* 将右边元素复制到TmpA */
		}	
	} 
	
	while(L<=LeftEnd){
		tmpA[tmp++]=a[L++];/* 直接复制左边剩下的 */
	}
	while(R<=RightEnd){
		tmpA[tmp++]=a[R++];/* 直接复制右边剩下的 */
	}
	
	int i;
	for(i=0;i<num;i++,RightEnd--){//L已经变了 找不到开头了 从结尾反着拷贝回去 
		a[RightEnd]=tmpA[RightEnd];/* 将有序的TmpA[]复制回A[] */
	}
} 
 
void Msort(int a[],int tmpA[],int L,int RightEnd)
{/* 核心递归排序函数 */
	int center;
	if(L<RightEnd){  //L==RightEnd只有一个数 也不用排 
		center=(L+RightEnd)/2;
		Msort(a,tmpA,L,center);
		Msort(a,tmpA,center+1,RightEnd);
		Merge(a,tmpA,L,center+1,RightEnd); 
	}
} 
```

### 非递归实现 ###

![1597930083957](../../../../../../img/in-post/2020-09-18-数据结构/1597930083957.png)

```c
/* length = 当前有序子列的长度*/
void Merge_pass(int a[],int tmpA[],int n,int length)//把第一个数组归并到第二个里 
{/* 两两归并相邻有序子列 */
	int i,j;
	for(i=0;i<=n-2*length;i+=2*length){//保证完整的两两归并 
		Merge(a,tmpA,i,i+length,i+2*length-1);
	}
	if(i+length<n){/* 归并最后2个子列----剩余的个数够一个length，不够两个length*/
		Merge(a,tmpA,i,i+length,n-1);//用一个length与后边的归并 
	}
	else{/* 最后只剩1个子列---剩余的个数不够一个length*/
		for(j=i;j<n;j++){//直接传递 
			tmpA[j]=a[j];
		}
	}	
} 

void Merge_Sort(int a[],int n)//稳定 
{
	int length;
	int tmpA[10000];
	length=1;/* 初始化子序列长度*/
	while(length<n){//a,tmpA互为存储排序结果的新数组，不用开很多个新数组 
		Merge_pass(a,tmpA,n,length);//a排序存到tmpA 
		length*=2;
		Merge_pass(tmpA,a,n,length);//更换步长，tmpA排序后存到a里 
		length*=2;
	} 
}

/* L = 左边起始位置, R = 右边起始位置, RightEnd = 右边终点位置*/ 
void Merge(int a[],int tmpA[],int L,int R,int RightEnd)
{
	/* 将有序的A[L]~A[R-1]和A[R]~A[RightEnd]归并成一个有序序列 */
	int LeftEnd=R-1;/* 左边终点位置 */
	int tmp=L;/* 有序序列的起始位置 */ 
	
	while(L<=LeftEnd&&R<=RightEnd){
		if(a[L]<a[R]){
			tmpA[tmp++]=a[L++];/* 将左边元素复制到TmpA */
		}
		else{
			tmpA[tmp++]=a[R++];/* 将右边元素复制到TmpA */
		}	
	} 
	
	while(L<=LeftEnd){
		tmpA[tmp++]=a[L++];/* 直接复制左边剩下的 */
	}
	while(R<=RightEnd){
		tmpA[tmp++]=a[R++];/* 直接复制右边剩下的 */
	}
} 
```

## 基数排序 ##

基数排序的方法一般采用“主位优先法” ( Most Significant Digit First, MSD) 或者“次位优先法” ( Least Significant Digit First, LSD)

**基数排序是稳定排序**

### 次位优先 ###

次位优先的过程是”分配—收集“

![1597931450964](../../../../../../img/in-post/2020-09-18-数据结构/1597931450964.png)

下例中，依次按照个位十位百位进行排序。

![1597930457071](../../../../../../img/in-post/2020-09-18-数据结构/1597930457071.png)

```c
/* 桶元素结点 */
typedef struct Node* PtrToNode;
struct Node{
	int key;
	PtrToNode next;
};

/* 桶头结点 */
typedef struct HeadNode{
	PtrToNode head;//无头节点的链表 head存值的 
	PtrToNode tail;
} Bucket[Radix];

#define Radix 10
int GetDigit(int x,int D)
{/* 默认次位D=1, 主位D<=MaxDigit */
	int i,d;
	for(i=1;i<=D;i++){
		d=x%Radix;
		x/=Radix;
	}
	return d;
}

void LSD_Radix_Sort(int a[],int n)
{/* 基数排序 - 次位优先 */
	int i;
	int D,Di;
	PtrToNode tmp,p,List=NULL,rear;
	
	Bucket B;
	for(i=0;i<Radix;i++){/* 初始化每个桶为空链表 */
		B[i].head=B[i].tail=NULL;
	}

	for(i=0;i<n;i++){/* 使用链表的头插法将原始序列逆序存入初始链表List */ 
		tmp=(PtrToNode)malloc(sizeof(struct Node));
		tmp->key=a[i];
		tmp->next=List;
		List=tmp;
	}//用链表List记录a[i]...而且逆序的，a[n-1]在表头
	 
	/* 下面开始排序 */ 
	for(D=1;D<=MaxDigit;D++){/* 对所有数据的每一位循环处理 */
		/* 下面是分配的过程 */
		p=List; //p指向List头节点 
		while(p){
			Di=GetDigit(p->key, D);/* 获得当前元素的当前位数字 */
			/* 从List中摘除 */
			tmp=p; //tmp记录的是要入桶的节点 
			p=p->next;
			//入桶，得到的数字是几就放在几号桶里边，每一个桶都是链表 
			/* 插入B[Di]号桶尾 */
			tmp->next=NULL;
			if(B[Di].head==NULL){ //桶里还没有元素 
				B[Di].head=B[Di].tail=tmp;
			}
			else{ //桶里有元素 
				B[Di].tail->next=tmp;//tmp接在桶尾的后边 
				B[Di].tail=tmp;//tmp成为新的尾 
			}
		}
		
		/* 下面是收集的过程 */
		List=NULL;
		//从最后一个桶反着来，链表就正过来了 
		for(Di=Radix-1;Di>=0;Di--){ /* 将每个桶的元素顺序收集入List */
			if(B[Di].head){/* 如果桶不为空 */
				/* 整桶插入List表头 */
				B[Di].tail->next=List;//把桶插在表的前边 （小桶放在大桶前边） 
				List=B[Di].head;//更新表头 
				B[Di].head=B[Di].tail=NULL;/* 清空桶 */
			}
		}
	}
	
	/* 将List倒入A[]并释放空间 */
	for(i=0;i<n;i++){
		a[i]=List->key;
		tmp=List;
		List=List->next;
		free(tmp);
	}
} 
```

### 主位优先 ###

主位优先相当于分治法

![1597931428539](../../../../../../img/in-post/2020-09-18-数据结构/1597931428539.png)

```c
/* 基数排序 - 主位优先 */
void MSD(int a[],int L,int R,int D)  //MSD(a,0,n-1,MaxDigit);
{ /* 核心递归函数: 对A[L]...A[R]的第D位数进行排序 */
	int i,j;
	int Di;
	PtrToNode tmp,p,List=NULL;
	
	if(D==0) return;/* 递归终止条件 */
	
	Bucket B;
	for(i=0;i<Radix;i++){/* 初始化每个桶为空链表 */
		B[i].head=B[i].tail=NULL;
	}
	
	for(i=L;i<=R;i++){/* 将原始序列逆序存入初始链表List */
		tmp=(PtrToNode)malloc(sizeof(struct Node));
		tmp->key=a[i];
		tmp->next=List;//tmp插在了表头 
		List=tmp;//表头名字变成List 
	}//用链表List记录a[i]...而且逆序的，a[n-1]在表头
	 
	/* 下面是分配的过程 */
	p=List;//p指向List头节点 
	while(p){
		Di=GetDigit(p->key,D);/* 获得当前元素的当前位数字 */
		/* 从List中摘除 */
		tmp=p;//记录的是要入桶的节点 
		p=p->next;
		tmp->next=NULL;
		//入桶，得到的数字是几就放在几号桶里边，每一个桶都是链表 
		/* 插入B[Di]号桶尾 */
		if(B[Di].head==NULL){//桶里还没有元素 
			B[Di].tail=B[Di].head=tmp;
		}
		else{
			//把tmp链到表上，放在head前边 
			tmp->next=B[Di].head;
			B[Di].head=tmp;	
		}	
	}	
	
	/* 下面是收集的过程 */
	i=j=L;/* i, j记录当前要处理的A[]的左右端下标 */
	for(Di=0;Di<Radix;Di++){ /* 将每个桶的元素顺序收集入List */
		if(B[Di].head){/* 如果桶不为空 */
			p=B[Di].head;//p指向这个桶 
			while(p){//把桶中元素记录在a[L]之后、、j=L 
				tmp=p;
				p=p->next;
				a[j++]=tmp->key;
				free(tmp);
			}
			//主位优先--需要递归再排序！！ 
			/* 递归对这个桶中数据排序, 位数减1 */
			MSD(a,i,j-1,D-1);//i=L,j++后变成了桶中元素结尾处，对此桶进行排序。 
			i=j;/* 为下一个桶对应的A[]左端---j会++，i记录j的初始位置，就是左端！！ */
		}
	}
} 
```

## 对比 ##

![1597931588766](../../../../../../img/in-post/2020-09-18-数据结构/1597931588766.png)

