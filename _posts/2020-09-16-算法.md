---
layout:     post
title:      "算法整理"
subtitle:   "算法及代码整理"
date:       2020-09-16
author:     "aptx1231"
header-img: "img/bg/2020-09-16-算法.jpg"
tags:       [禁止转载,教程,算法,C++]
categories: [教程]
catalog:    []
---

>部分截图来自北京航空航天大学授课老师PPT，请勿转载

### 基础 ###

#### Θ,O,Ω ####

![1577675959365](../../../../../../img/in-post/2020-09-16-算法/1577675959365.png)

![1577675934190](../../../../../../img/in-post/2020-09-16-算法/1577675934190.png)

![1577676061953](../../../../../../img/in-post/2020-09-16-算法/1577676061953.png)

![1577676107543](../../../../../../img/in-post/2020-09-16-算法/1577676107543.png)

![1577676152919](../../../../../../img/in-post/2020-09-16-算法/1577676152919.png)

![1577676283477](../../../../../../img/in-post/2020-09-16-算法/1577676283477.png)

![1577677163251](../../../../../../img/in-post/2020-09-16-算法/1577677163251.png)

![1577677193020](../../../../../../img/in-post/2020-09-16-算法/1577677193020.png)

#### 主定理 ####

主定理必考

主定理一般形式也要记

![1577677956729](../../../../../../img/in-post/2020-09-16-算法/1577677956729.png)

![1577678051887](../../../../../../img/in-post/2020-09-16-算法/1577678051887.png)

![1577678086093](../../../../../../img/in-post/2020-09-16-算法/1577678086093.png)

![1577678098612](../../../../../../img/in-post/2020-09-16-算法/1577678098612.png)

![1577678114165](../../../../../../img/in-post/2020-09-16-算法/1577678114165.png)

![1577679409076](../../../../../../img/in-post/2020-09-16-算法/1577679409076.png)

![1577679660794](../../../../../../img/in-post/2020-09-16-算法/1577679660794.png)

![1577679508222](../../../../../../img/in-post/2020-09-16-算法/1577679508222.png)

![1577679542475](../../../../../../img/in-post/2020-09-16-算法/1577679542475.png)

### 分治 ###

#### 多项式乘法 ####

![1577689262125](../../../../../../img/in-post/2020-09-16-算法/1577689262125.png)

![1577689239023](../../../../../../img/in-post/2020-09-16-算法/1577689239023.png)

![1577689221116](../../../../../../img/in-post/2020-09-16-算法/1577689221116.png)

#### 快速排序 ####

![1577689385409](../../../../../../img/in-post/2020-09-16-算法/1577689385409.png)

![1577689395887](../../../../../../img/in-post/2020-09-16-算法/1577689395887.png)

![1577689413027](../../../../../../img/in-post/2020-09-16-算法/1577689413027.png)

#### 计数排序 ####

![1577690529772](../../../../../../img/in-post/2020-09-16-算法/1577690529772.png)

#### 选第k小的数 ####

![1577690596659](../../../../../../img/in-post/2020-09-16-算法/1577690596659.png)

**复杂度O(n)**

复习作业题，作业题变种

活动选择问题，**贪心转动规**呢 带权重

### 动态规划 ###

#### 背包 ####

##### 01背包 #####

![1577693856907](../../../../../../img/in-post/2020-09-16-算法/1577693856907.png)

![1577693899165](../../../../../../img/in-post/2020-09-16-算法/1577693899165.png)

空间优化

![1577693968812](../../../../../../img/in-post/2020-09-16-算法/1577693968812.png)

##### 01背包问方法数 #####

![1577693619121](../../../../../../img/in-post/2020-09-16-算法/1577693619121.png)

![1577693604030](../../../../../../img/in-post/2020-09-16-算法/1577693604030.png)

![1577694110958](../../../../../../img/in-post/2020-09-16-算法/1577694110958.png)

##### 01背包变化 #####

取糖果

取的越多越好，总数要求的k的倍数。

![1577720288867](../../../../../../img/in-post/2020-09-16-算法/1577720288867.png)

![1577720301534](../../../../../../img/in-post/2020-09-16-算法/1577720301534.png)

##### 完全背包 #####

物品可以选多个 （任意多）

dp\[i][j]代表前i个物品，重量不超过j时的最大价值

完全背包 dp\[i][j] = max(dp\[i-1\]\[j\], dp\[i][j-t[i]]+v[i]);   //区别就是第二项的dp[i] 01背包是dp[i-1]

![1577694343720](../../../../../../img/in-post/2020-09-16-算法/1577694343720.png)

##### 多重背包 #####

有*n* 种物品和一个容量为W 的背包。第*i* 种物品有ci 个，每件重量为pi ， 价值为hi ，求从这n 种物品中挑选重量总和不超过*W* 的物品的最大价值。

转化成01背包求解即可。

![1577694946370](../../../../../../img/in-post/2020-09-16-算法/1577694946370.png)

##### 二维背包 #####

约束条件有两个 满足两个约束下的最大价值

二维背包问题是指每件物品都具有两种条件，选择这件物品要满足这两个条件，求选择物品得到最大的权重。

相比经典的01背包问题，二维背包问题增加了一维开销，于是我们需要在状态上增加一维。

设s\[i]\[j]\[k]表示将前 i 件物品放入两种容量分别为 j 和 k 的背包时所能获得的最大权重，

状态转移方程为  s\[i]\[j]\[k]=max{s\[i-1]\[j]\[k], s\[i-1]\[j-v\[i]][k-u[i]]+w[i]}，

边界为 当i=0时s\[i]\[j][k]=0  

类似01背包可以降低到二维dp[][] 

![1577694784146](../../../../../../img/in-post/2020-09-16-算法/1577694784146.png)

#### 区间DP ####

##### 矩阵链乘 #####

![1577689752307](../../../../../../img/in-post/2020-09-16-算法/1577689752307.png)

##### 最优二叉搜索树 #####

![1577691458945](../../../../../../img/in-post/2020-09-16-算法/1577691458945.png)

##### 括号匹配问题 #####

![1577695086131](../../../../../../img/in-post/2020-09-16-算法/1577695086131.png)

![1577695126198](../../../../../../img/in-post/2020-09-16-算法/1577695126198.png)

##### 石子合并 #####

![1577695194899](../../../../../../img/in-post/2020-09-16-算法/1577695194899.png)

![1577695223810](../../../../../../img/in-post/2020-09-16-算法/1577695223810.png)

![1577695420919](../../../../../../img/in-post/2020-09-16-算法/1577695420919.png)

##### 加分二叉树 #####

![1577695786390](../../../../../../img/in-post/2020-09-16-算法/1577695786390.png)

![1577695822673](../../../../../../img/in-post/2020-09-16-算法/1577695822673.png)

#### 一维DP ####

##### 最长上升子序列 #####

n^2方法

![1577692645472](../../../../../../img/in-post/2020-09-16-算法/1577692645472.png)

![1577696027476](../../../../../../img/in-post/2020-09-16-算法/1577696027476.png)

nlogn方法

![1577719300100](../../../../../../img/in-post/2020-09-16-算法/1577719300100.png) 

![1577719397381](../../../../../../img/in-post/2020-09-16-算法/1577719397381.png)

![1577719567131](../../../../../../img/in-post/2020-09-16-算法/1577719567131.png)

##### 开餐馆 #####

位置di，利润pi，相邻距离>=k

![1577697234335](../../../../../../img/in-post/2020-09-16-算法/1577697234335.png)

![1577697076334](../../../../../../img/in-post/2020-09-16-算法/1577697076334.png)

![1577697127486](../../../../../../img/in-post/2020-09-16-算法/1577697127486.png)

##### 大盗阿福 #####

偷钱 相邻位置不能连续偷

![1577697494007](../../../../../../img/in-post/2020-09-16-算法/1577697494007.png)

![1577697372446](../../../../../../img/in-post/2020-09-16-算法/1577697372446.png)

##### 活动选择

![1577713950554](../../../../../../img/in-post/2020-09-16-算法/1577713950554.png)

![1577713922005](../../../../../../img/in-post/2020-09-16-算法/1577713922005.png)

![1577714017194](../../../../../../img/in-post/2020-09-16-算法/1577714017194.png)

##### 切割回文 #####

通过切割字符串，使得切割完之后得到的子串都是回文的。求最小切割次数。

![1577721270405](../../../../../../img/in-post/2020-09-16-算法/1577721270405.png)

![1577721283696](../../../../../../img/in-post/2020-09-16-算法/1577721283696.png)

##### 最大子矩阵 #####

![1577723101072](../../../../../../img/in-post/2020-09-16-算法/1577723101072.png)

#### 二维DP ####

##### 数组分段和的最大值最小化问题 #####

给定一个数组，和一个值k，数组分成k段。要求这k段子段和最大值最小。求出这个值。

![1577717291796](../../../../../../img/in-post/2020-09-16-算法/1577717291796.png)

![1577717309836](../../../../../../img/in-post/2020-09-16-算法/1577717309836.png)

##### 最佳加法表达式 #####

给定n个1到9的数字，要求在数字之间摆放m个加号
(加号两边必须有数字），使得所得到的加法表达式的值最小

![1577692951540](../../../../../../img/in-post/2020-09-16-算法/1577692951540.png)

![1577693235368](../../../../../../img/in-post/2020-09-16-算法/1577693235368.png)

##### 乘积最大 #####

给定n个1到9的数字，要求在数字之间摆放m个乘号 要求乘积最大。

![1577716451553](../../../../../../img/in-post/2020-09-16-算法/1577716451553.png)

##### 最小编辑距离 #####

![1577720807009](../../../../../../img/in-post/2020-09-16-算法/1577720807009.png)

![1577689873766](../../../../../../img/in-post/2020-09-16-算法/1577689873766.png)

![1577720897256](../../../../../../img/in-post/2020-09-16-算法/1577720897256.png)

对于两个不同的字符串，我们有一套操作方法来把他们变得相同，具体方法为：

修改一个字符（如把“a”替换为“b”）

删除一个字符（如把“traveling”变为“travelng”）

![1577720695364](../../../../../../img/in-post/2020-09-16-算法/1577720695364.png)

![1577720744010](../../../../../../img/in-post/2020-09-16-算法/1577720744010.png)

##### 基因相似度 #####

![1577718817713](../../../../../../img/in-post/2020-09-16-算法/1577718817713.png)

![1577718842956](../../../../../../img/in-post/2020-09-16-算法/1577718842956.png)

![1577718891049](../../../../../../img/in-post/2020-09-16-算法/1577718891049.png)

##### 最长公共子序列 ##### 

![1577689997951](../../../../../../img/in-post/2020-09-16-算法/1577689997951.png)

![1577690015617](../../../../../../img/in-post/2020-09-16-算法/1577690015617.png)

#####  最长公共子串 ##### 

![1577689928568](../../../../../../img/in-post/2020-09-16-算法/1577689928568.png)

![1577689968609](../../../../../../img/in-post/2020-09-16-算法/1577689968609.png)

##### 传球 #####

*n*个同学站成一个圆圈，有多少种不同的传球方法可以使得从小蛮手里开始传的球，传了m*m*次以后，又回到小蛮手里。小蛮是1号。

![1577719803206](../../../../../../img/in-post/2020-09-16-算法/1577719803206.png)

![1577719875700](../../../../../../img/in-post/2020-09-16-算法/1577719875700.png)

#### 多维DP ###

##### 分蛋糕 #####

![1577696887187](../../../../../../img/in-post/2020-09-16-算法/1577696887187.png)

![1577696821273](../../../../../../img/in-post/2020-09-16-算法/1577696821273.png)

##### 传纸条 #####

四维

![1577715840761](../../../../../../img/in-post/2020-09-16-算法/1577715840761.png)

![1577715859218](../../../../../../img/in-post/2020-09-16-算法/1577715859218.png)

三维

![1577715920674](../../../../../../img/in-post/2020-09-16-算法/1577715920674.png)

![1577715999684](../../../../../../img/in-post/2020-09-16-算法/1577715999684.png)

##### 方格取数 #####

四维

![1577716148664](../../../../../../img/in-post/2020-09-16-算法/1577716148664.png)

![1577716178007](../../../../../../img/in-post/2020-09-16-算法/1577716178007.png)

三维

![1577716226274](../../../../../../img/in-post/2020-09-16-算法/1577716226274.png)

![1577716239189](../../../../../../img/in-post/2020-09-16-算法/1577716239189.png)

### 贪心 ###

不需要证明

### 深度优先搜索 ###



### 广度优先搜索 ###



### 图 ###

运行实例：BFS,DFS,强联通分量,最小生成树（区分两种算法）,单源最短路径

#### 基本概念 ####

![1577583913090](../../../../../../img/in-post/2020-09-16-算法/1577583913090.png)

![1577583929000](../../../../../../img/in-post/2020-09-16-算法/1577583929000.png)

![1577583959886](../../../../../../img/in-post/2020-09-16-算法/1577583959886.png)

acyclic 非循环的

![1577584063929](../../../../../../img/in-post/2020-09-16-算法/1577584063929.png)

![1577584137198](../../../../../../img/in-post/2020-09-16-算法/1577584137198.png)

![1577584389116](../../../../../../img/in-post/2020-09-16-算法/1577584389116.png)

![1577584648581](../../../../../../img/in-post/2020-09-16-算法/1577584648581.png)

#### BFS ####

![1577586053974](../../../../../../img/in-post/2020-09-16-算法/1577586053974.png)

![1577586078417](../../../../../../img/in-post/2020-09-16-算法/1577586078417.png)

![1577586098209](../../../../../../img/in-post/2020-09-16-算法/1577586098209.png)

![1577586131166](../../../../../../img/in-post/2020-09-16-算法/1577586131166.png)

用了标记数组，访问过的点不会重复入队，也就是边不会重复访问，但是还是会访问所有的点，所有的边 ，E可能是V^2级别的，不能忽略。如果是树的话，E=V-1，复杂度就是O(V)的了。而且树不需要标记数组。

#### DFS ####

![1577586213721](../../../../../../img/in-post/2020-09-16-算法/1577586213721.png)

![1577586248689](../../../../../../img/in-post/2020-09-16-算法/1577586248689.png)

![1577586321390](../../../../../../img/in-post/2020-09-16-算法/1577586321390.png)

![1577586353632](../../../../../../img/in-post/2020-09-16-算法/1577586353632.png)

用了标记数组，访问过的点不会重复递归访问，也就是边不会重复访问，但是还是会访问所有的点，所有的边 ，E可能是V^2级别的，不能忽略。如果是树的话，E=V-1，复杂度就是O(V)的了。而且树不需要标记数组。

![1577587116593](../../../../../../img/in-post/2020-09-16-算法/1577587116593.png)

![1577587134179](../../../../../../img/in-post/2020-09-16-算法/1577587134179.png)

![1577587153993](../../../../../../img/in-post/2020-09-16-算法/1577587153993.png)

![1577587166331](../../../../../../img/in-post/2020-09-16-算法/1577587166331.png)

![1577587239846](../../../../../../img/in-post/2020-09-16-算法/1577587239846.png)

#### 拓扑排序 ####

![1577587343739](../../../../../../img/in-post/2020-09-16-算法/1577587343739.png)

![1577587425295](../../../../../../img/in-post/2020-09-16-算法/1577587425295.png)

![1577587531276](../../../../../../img/in-post/2020-09-16-算法/1577587531276.png)

![1577587612181](../../../../../../img/in-post/2020-09-16-算法/1577587612181.png)

![1577587651074](../../../../../../img/in-post/2020-09-16-算法/1577587651074.png)

![1577588371243](../../../../../../img/in-post/2020-09-16-算法/1577588371243.png)

![1577586213721](../../../../../../img/in-post/2020-09-16-算法/1577586213721.png)

计算f[u]时，说明u的邻接点都访问完成，此时把u插入排序数组topsort[]，topsort的逆序就是拓扑排序的顺序。

对任一对不同顶点u、v∈V，若G中存在一条从u到v的边，则f[v]<f[u]。

#### 强连通分量 ####

有向图强[连通分量](https://baike.baidu.com/item/%E8%BF%9E%E9%80%9A%E5%88%86%E9%87%8F/290350)：在[有向图](https://baike.baidu.com/item/%E6%9C%89%E5%90%91%E5%9B%BE/1852743)G中，如果两个顶点vi,vj间（vi>vj）有一条从vi到vj的有向路径，同时还有一条从vj到vi的有向路径，则称两个顶点[强连通](https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A/1131406)(strongly connected)。如果有向图G的每两个顶点都强连通，称G是一个[强连通图](https://baike.baidu.com/item/%E5%BC%BA%E8%BF%9E%E9%80%9A%E5%9B%BE/6769617)。有向图的极大强连通子图，称为强连通分量(strongly connected components)。

![1577607548119](../../../../../../img/in-post/2020-09-16-算法/1577607548119.png)

![1577607676661](../../../../../../img/in-post/2020-09-16-算法/1577607676661.png)

![1577608017681](../../../../../../img/in-post/2020-09-16-算法/1577608017681.png)

![1577611961588](../../../../../../img/in-post/2020-09-16-算法/1577611961588.png)

按照访问完成的顺序，也就是变黑的顺序，求出LR

![1577612001390](../../../../../../img/in-post/2020-09-16-算法/1577612001390.png)

![1577612140726](../../../../../../img/in-post/2020-09-16-算法/1577612140726.png)

![1577612156756](../../../../../../img/in-post/2020-09-16-算法/1577612156756.png)

![1577609530959](../../../../../../img/in-post/2020-09-16-算法/1577609530959.png)

![1577609577414](../../../../../../img/in-post/2020-09-16-算法/1577609577414.png)

![1577609587067](../../../../../../img/in-post/2020-09-16-算法/1577609587067.png)

![1577609596900](../../../../../../img/in-post/2020-09-16-算法/1577609596900.png)

![1577609610808](../../../../../../img/in-post/2020-09-16-算法/1577609610808.png)

![1577609623540](../../../../../../img/in-post/2020-09-16-算法/1577609623540.png)

![1577609645197](../../../../../../img/in-post/2020-09-16-算法/1577609645197.png)

#### 最小生成树 ####

![1577612641545](../../../../../../img/in-post/2020-09-16-算法/1577612641545.png)

![1577612657732](../../../../../../img/in-post/2020-09-16-算法/1577612657732.png)

![1577612703827](../../../../../../img/in-post/2020-09-16-算法/1577612703827.png)

![1577617559661](../../../../../../img/in-post/2020-09-16-算法/1577617559661.png)

![1577617580752](../../../../../../img/in-post/2020-09-16-算法/1577617580752.png)

![1577617597763](../../../../../../img/in-post/2020-09-16-算法/1577617597763.png)

##### Prim #####

![1577617735394](../../../../../../img/in-post/2020-09-16-算法/1577617735394.png)

![1577617758170](../../../../../../img/in-post/2020-09-16-算法/1577617758170.png)

![1577617881707](../../../../../../img/in-post/2020-09-16-算法/1577617881707.png)

![1577619580947](../../../../../../img/in-post/2020-09-16-算法/1577619580947.png)

![1577618026516](../../../../../../img/in-post/2020-09-16-算法/1577618026516.png)

![1577618287946](../../../../../../img/in-post/2020-09-16-算法/1577618287946.png)

![1577618361495](../../../../../../img/in-post/2020-09-16-算法/1577618361495.png)

![1577618412884](../../../../../../img/in-post/2020-09-16-算法/1577618412884.png)

##### Kruskal #####

![1577618548337](../../../../../../img/in-post/2020-09-16-算法/1577618548337.png)

![1577618578451](../../../../../../img/in-post/2020-09-16-算法/1577618578451.png)

![1577619051330](../../../../../../img/in-post/2020-09-16-算法/1577619051330.png)

#### 单源最短路 #####

##### Dijkstra #####

![1577619520598](../../../../../../img/in-post/2020-09-16-算法/1577619520598.png)

![1577619676585](../../../../../../img/in-post/2020-09-16-算法/1577619676585.png)

![1577619700071](../../../../../../img/in-post/2020-09-16-算法/1577619700071.png)

![1577620116334](../../../../../../img/in-post/2020-09-16-算法/1577620116334.png)

![1577620288573](../../../../../../img/in-post/2020-09-16-算法/1577620288573.png)

##### Bellman-Ford #####

![1577620495319](../../../../../../img/in-post/2020-09-16-算法/1577620495319.png)

![1577620393715](../../../../../../img/in-post/2020-09-16-算法/1577620393715.png)

![1577620408234](../../../../../../img/in-post/2020-09-16-算法/1577620408234.png)

![1577620646829](../../../../../../img/in-post/2020-09-16-算法/1577620646829.png)

### 难问题 ###

![1577622022346](../../../../../../img/in-post/2020-09-16-算法/1577622022346.png)

![1577622136114](../../../../../../img/in-post/2020-09-16-算法/1577622136114.png)

![1577622155327](../../../../../../img/in-post/2020-09-16-算法/1577622155327.png)

![1577622279030](../../../../../../img/in-post/2020-09-16-算法/1577622279030.png)

![1577622294950](../../../../../../img/in-post/2020-09-16-算法/1577622294950.png)

![1577622448565](../../../../../../img/in-post/2020-09-16-算法/1577622448565.png)

![1577622460840](../../../../../../img/in-post/2020-09-16-算法/1577622460840.png)

#### P ####

![1577622594344](../../../../../../img/in-post/2020-09-16-算法/1577622594344.png)

![1577624024848](../../../../../../img/in-post/2020-09-16-算法/1577624024848.png)

![1577624053317](../../../../../../img/in-post/2020-09-16-算法/1577624053317.png)

![1577624131614](../../../../../../img/in-post/2020-09-16-算法/1577624131614.png)

![1577624154562](../../../../../../img/in-post/2020-09-16-算法/1577624154562.png)

![1577624947439](../../../../../../img/in-post/2020-09-16-算法/1577624947439.png)

#### NP ####

![1577624988338](../../../../../../img/in-post/2020-09-16-算法/1577624988338.png)

![1577625495480](../../../../../../img/in-post/2020-09-16-算法/1577625495480.png)

![1577625505839](../../../../../../img/in-post/2020-09-16-算法/1577625505839.png)

![1577625518003](../../../../../../img/in-post/2020-09-16-算法/1577625518003.png)

![1577625534421](../../../../../../img/in-post/2020-09-16-算法/1577625534421.png)

![1577626082621](../../../../../../img/in-post/2020-09-16-算法/1577626082621.png)

#### NPC ####

![1577627450487](../../../../../../img/in-post/2020-09-16-算法/1577627450487.png)

![1577629893855](../../../../../../img/in-post/2020-09-16-算法/1577629893855.png)

![1577629916243](../../../../../../img/in-post/2020-09-16-算法/1577629916243.png)

![1577629965914](../../../../../../img/in-post/2020-09-16-算法/1577629965914.png)

![1577630035908](../../../../../../img/in-post/2020-09-16-算法/1577630035908.png)

第一个好理解，因为所有NP都能多项式时间规约到L，L被解决，所有NP都解决。

第二个L可以规约到所有的NPC，反证法，如果这些NPC能解决，L就能解决，与L不能解决矛盾，所以L不能解决，这些NPC都不能解决。

只有有一个NPC（即L）不能解决，那么所有NPC都解决不了。

![1577630229456](../../../../../../img/in-post/2020-09-16-算法/1577630229456.png)

![1577630293275](../../../../../../img/in-post/2020-09-16-算法/1577630293275.png)

![1577630539845](../../../../../../img/in-post/2020-09-16-算法/1577630539845.png)

![1577630326082](../../../../../../img/in-post/2020-09-16-算法/1577630326082.png)

#### NP-Hard ####

![1577630425296](../../../../../../img/in-post/2020-09-16-算法/1577630425296.png)





